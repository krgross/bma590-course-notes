best.contract <- ttt$contract
payoff <- ttt$payoff
my.hessian <- ttt$hessian
return(list(r = best.r, e = best.e, contract = best.contract, payoff = payoff, hessian = my.hessian))
}
plot.all.contracts <- function(do.print = F) {
if (do.print) {
pdf(file = "C:/Users/krgross/Documents/Projects/science-contract/figures/optimal-contracts-cts-effort.pdf", width = 5, height = 4)
}
par(mar = c(5, 4, 1, 1), las = 1)
## binary effort
plot.contracts(add.legend = F, do.print = F)
## cts effort model 1
contract.sb <- optimize.re()$contract$root
u0.sb <- contract.sb[1]
a.sb  <- contract.sb[2]
b.sb  <- contract.sb[3]
h <- function(u) u^2
u <- function(v, u0, a, b) ifelse(v > 0, a + b * v, u0)
u.sb <- function(v) u(v, u0.sb, a.sb, b.sb)
u.sp <- function(v) u(v, u0.sp, a.sp, b.sp)
v.vals <- seq(from = 1e-2, to = 1, length = 100)
# wages vs v
lines(v.vals, h(u.sb(v.vals)), lty = "dotdash")
points(0, a.sb^2, pch = 2, xpd = T)
points(0, h(u.sb(0)), pch = 17, xpd = T)
## cts effort model 2
contract.sb <- optimize.re.2()$contract$root
u0.sb <- contract.sb[1]
a.sb  <- contract.sb[2]
b.sb  <- contract.sb[3]
# wages vs v
lines(v.vals, h(u.sb(v.vals)), lty = "longdash")
points(0, a.sb^2, pch = 6, xpd = T)
points(0, h(u.sb(0)), pch = 25, col = "black", bg = "black", xpd = T)
legend("topleft", leg = c("community's contract, model I", "community's contract, model II",
"community's contract, model III", "planner's contract"),
lty = c("solid", "dotdash", "longdash", "dashed"), col = c("black", "black", "black", "blue"),
pt.bg = c("black", "black", "black", "blue"),
pch = c(16, 17, 25, 16), bty = "n")
if (do.print) {
dev.off()
}
}
optimize.re.2()
ttt <- .Last.value
sqrt(ttt$e)
with(ttt, e * r * (1 - r))
with(ttt, e * r * (1 - r))/.25
1-with(ttt, e * r * (1 - r))/.25
sample(18)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width = 4, fig.height = 4, fig.align = "center")
require(rootSolve)
implement.r <- function(r = 0.5, cost = 0.2, start.vals = NULL){
# Find the best contract to implement r
eqn.set <- function(x, parms) {
r    <- parms[1]
cost <- parms[2]
u0  <- x[1]
a   <- x[2]
b   <- x[3]
c(F1 = r * (1 - r) - r * u0^2 - (1 - r) * (a^2 + 2 * a * b * r + 2 * b^2 * r^2),   # BC
F2 = (1 - r) * (a + b * r - u0) - cost,  # EC
F3 = u0 + b - a - 2 * b * r           # FOC for RC
)
}
if (is.null(start.vals)) {
start.vals <- c(0.15, 0.37, 0.44)  # near the solution for r = 0.25
}
multiroot(eqn.set, start = start.vals, parms = c(r, cost))
}
optimize.r <- function(cost = 0.2){
my.f <- function(r) implement.r(r, cost = cost)$root[1]
best.r <- optimize(my.f, lower = 0, upper = 0.5, maximum = TRUE)
ttt <- implement.r(r = best.r$maximum)
best.contract <- ttt$root
return(list(r = best.r, contract = best.contract, payoff = best.r$objective))
}
social.planner.pc <- function(cost = 0.2, pi.r = 0.05, start.vals = NULL) {
# find the social planner's solution under the constraint that u0 = pi_r
eqn.set <- function(x, parms) {
u0   <- parms[1]
cost <- parms[2]
r   <- x[1]
a   <- x[2]
b   <- x[3]
c(F1 = r * (1 - r) - r * u0^2 - (1 - r) * (a^2 + 2 * a * b * r + 2 * b^2 * r^2),   # BC
F2 = (1 - r) * (a + b * r - u0) - cost,  # EC
F3 = u0 + b - a - 2 * b * r           # FOC for RC
)
}
if (is.null(start.vals)) {
start.vals <- c(0.5, 0.1, 0.8)  # near the solution for r = 0.25
}
multiroot(eqn.set, start = start.vals, parms = c(pi.r, cost))
}
social.planner <- function(cost = 0.2, pi.r = 0.1, start.vals = NULL) {
fb.solution <- implement.r(r = 0.5, cost = cost, start.vals = start.vals)
if (fb.solution$root[1] >= pi.r) ans <- list(r = 0.5, contract = fb.solution$root)
else {
pc.solution <- social.planner.pc(cost = cost, pi.r = pi.r, start.vals = start.vals)
ans <- list(r = pc.solution$root[1], contract = c(pi.r, pc.solution$root[2:3]))
}
ans
}
plot.payoff <- function(do.print = F) {
if (do.print) {
pdf(file = "C:/Users/krgross/Documents/Projects/science-contract/figures/numerical-example.pdf", width = 5, height = 4)
}
pi.r <- 0
par(mar = c(5, 4, 1, 1), las = 1)
r.min <- uniroot(function(r) implement.r(r = r)$root[1] - pi.r, interval = c(0.01, 0.5))$root
r.sb <- optimize.r()$maximum
r.vals <- seq(from = r.min, to = 0.5, length = 100)
pi.vals <- double(length = length(r.vals))
for (i in seq(along = r.vals)) pi.vals[i] <- implement.r(r = r.vals[i])$root[1]
full.info.pi <- function(r) sqrt(r * (1 - r)) - 0.2 # remember to subtract the cost
plot(r.vals, pi.vals, type = "l", xlim = c(0, 0.5),
ylim = c(0, full.info.pi(0.5)),
#ylim = c(0, 1.04 * max(pi.vals)),
xlab = "scientific risk, r", ylab = expression(paste("community payoff, ", pi(r), sep = " ")),
xaxs = "i", yaxs = "i", bty = "l")
full.info.min <- uniroot(function(r) full.info.pi(r) - pi.r, interval = c(0, 0.5))$root
curve(full.info.pi, from = full.info.min, to = 0.5, add = T, lty = "dashed")
points(x = r.sb, y = implement.r(r = r.sb)$root[1], pch = 16)
points(x = 0.5, y = implement.r(r = 0.5)$root[1], pch = 8, xpd = T, col = "blue")
segments(x0 = r.sb, y0 = 0, y1 = implement.r(r = r.sb)$root[1], lty = "dotted")
axis(1, at = r.sb, lab = expression(tilde(r)))
# axis(2, at = pi.r, lab = expression(pi[R]))
# abline(h = pi.r, col = "gray")
legend("topleft", leg = c("full information", "hidden action", "community solution", "planner's solution"),
lty = c("dashed", "solid", NA, NA),
pch = c(NA, NA, 16, 8),
col = c("black", "black", "black", "blue"),
bty = "n",
cex = 0.7)
if (do.print) {
dev.off()
}
}
plot.contracts <- function(add.legend = T, do.print = F) {
if (do.print) {
pdf(file = "C:/Users/krgross/Documents/Projects/science-contract/figures/optimal-contracts.pdf", width = 5, height = 4)
}
par(mar = c(5, 4, 1, 1), las = 1)
r.fb <- 0.5
contract.sb <- optimize.r()$contract
contract.sp <- implement.r(r = r.fb)$root
u0.sb <- contract.sb[1]
a.sb  <- contract.sb[2]
b.sb  <- contract.sb[3]
u0.sp <- contract.sp[1]
a.sp  <- contract.sp[2]
b.sp  <- contract.sp[3]
h <- function(u) u^2
u <- function(v, u0, a, b) ifelse(v > 0, a + b * v, u0)
u.sb <- function(v) u(v, u0.sb, a.sb, b.sb)
u.sp <- function(v) u(v, u0.sp, a.sp, b.sp)
v.vals <- seq(from = 1e-2, to = 2 * r.fb, length = 100)
# wages vs v
plot(v.vals, h(u.sp(v.vals)), xlim = c(0, max(v.vals)), ylim = c(0, h(u.sp(max(v.vals)))),
xlab = "scientific value, v", ylab = "wages, w(v)",
bty = "l", type = "l", lty = "dashed", col = "blue",
xaxs = "i", yaxs = "i")
points(0, h(u.sp(0)), pch = 16, xpd = T, col = "blue")
lines(v.vals, h(u.sb(v.vals)))
points(0, a.sb^2, pch = 1, xpd = T)
points(0, h(u.sb(0)), pch = 16, xpd = T)
if (add.legend) {
legend("topleft", leg = c("community's contract", "planner's contract"),
lty = c("solid", "dashed"), col = c("black", "blue"), bty = "n")
}
if (do.print) {
dev.off()
}
}
make.payoff.plot <- function(do.print = F) {
if (do.print) {
pdf(file = "C:/Users/krgross/Documents/Projects/science-contract/figures/numerical-example-binary-effort.pdf", width = 7.5, height = 4)
}
par(mfrow = c(1, 2))
plot.payoff(F)
legend("bottomright", leg = "A", text.font = 2, bty = "n", cex = 1.5)
plot.contracts(F)
legend("bottomright", leg = "B", text.font = 2, bty = "n", cex = 1.5)
if (do.print) {
dev.off()
}
}
first.best.e <- function(r = 0.5, bet = 1, gam = 0.1) {
# First best effort under continuous-effort model 1.
# This is strictly for the case when the budget is linear in the science
# and the cost of effort is quadratic in effort.
(bet * r * (1 - r))^(1/3) / (4 * gam) ^ (2/3)
}
require(rootSolve)
implement.re <- function(r = 0.5, e = 1, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e, budget = function(s) s,
start.vals = NULL){
# Find the best contract to implement r.  See p. 5/81 for equations
eqn.set <- function(x, parms) {
r    <- parms[1]
e    <- parms[2]
u0  <- x[1]
a   <- x[2]
b   <- x[3]
c(F1 = budget(e * r * (1 - r)) - (1 - e) * u0^2 - e * (r * u0^2 + (1 - r) * (a^2 + 2 * a * b * r + 2 * b^2 * r^2)),   # BC
F2 = (1 - r) * (a + b * r - u0) - dcost(e),  # EC
F3 = u0 + b - a - 2 * b * r           # FOC for RC
)
}
if (is.null(start.vals)) {
start.vals <- c(0.15, 0.37, 0.44)  # near the solution for r = 0.25, e = 1
}
payoff <- function(r, e, u0, a, b) (1 - e) * u0 + e * (u0 * r + (1 - r) * (a + b * r)) - cost(e)
contract <- multiroot(eqn.set, start = start.vals, parms = c(r, e))
my.payoff <- payoff(r = r, e = e, u0 = contract$root[1], a = contract$root[2], b = contract$root[3])
return(list(contract = contract, payoff = my.payoff))
}
optimize.r.at.e <- function(e = 1, budget = function(s) s, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e){
# find the best r for a given e
my.f <- function(r) implement.re(r, cost = cost, dcost = dcost, e = e)$payoff
optimize(my.f, lower = 0, upper = 0.5, maximum = TRUE)
}
optimize.e <- function(budget = function(s) s, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e){
# find the best r for a given e
my.f <- function(e) optimize.r.at.e(e, budget = budget, cost = cost, dcost = dcost)$objective
optimize(my.f, lower = 0, upper = 1, maximum = TRUE)
}
optimize.re <- function(budget = function(s) s, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e){
# find the best r for a given e
best.e <- optimize.e(budget = budget)$maximum
best.r <- optimize.r.at.e(e = best.e, budget = budget, cost = cost, dcost = dcost)$maximum
ttt <- implement.re(r = best.r, e = best.e, budget = budget)
best.contract <- ttt$contract
payoff <- ttt$payoff
return(list(r = best.r, e = best.e, contract = best.contract, payoff = payoff))
}
require(rootSolve)
implement.re.2 <- function(r = 0.5, e = 1, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e, budget = function(s) s,
start.vals = NULL){
# Find the best contract to implement r.  See p. 5/81 for equations
eqn.set <- function(x, parms) {
r    <- parms[1]
e    <- parms[2]
u0  <- x[1]
a   <- x[2]
b   <- x[3]
c(F1 = budget(e * r * (1 - r)) - (1 - sqrt(e)) * u0^2 - sqrt(e) * (r * u0^2 + (1 - r) * (a^2 + 2 * a * b * r * sqrt(e) + 2 * b^2 * r^2 * e)),   # BC
F2 = (1 / (2 * sqrt(e))) * (1 - r) * (a + 2 * b * r * sqrt(e) - u0) - dcost(e),  # EC
F3 = u0 + b * sqrt(e) - a - 2 * b * r * sqrt(e)           # FOC for RC
)
}
if (is.null(start.vals)) {
start.vals <- c(0.15, 0.37, 0.44)  # near the solution for r = 0.25, e = 1
}
payoff <- function(r, e, u0, a, b) (1 - sqrt(e)) * u0 + sqrt(e) * (u0 * r + (1 - r) * (a + b * r * sqrt(e))) - cost(e)
contract <- multiroot(eqn.set, start = start.vals, parms = c(r, e))
u0 <- contract$root[1]
a <- contract$root[2]
b <- contract$root[3]
my.payoff <- payoff(r = r, e = e, u0 = u0, a = a, b = b)
hessian.rr <- -2 * b * e
hessian.re <- (1 / 2 * sqrt(e)) * (u0 - a - 4 * b * r * sqrt(e) + 2 * b * sqrt(e))
hessian.ee <- ((1 - r) / 2) * (b * r / e - (2 * b * r * sqrt(e) - u0 + a) / (2 * e^(3/2))) - 0.2
my.hessian <- matrix(c(hessian.rr, hessian.re, hessian.re, hessian.ee), nrow = 2)
return(list(contract = contract, payoff = my.payoff, hessian = my.hessian))
}
optimize.r.at.e.2<- function(e = 1, budget = function(s) s, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e){
# find the best r for a given e
my.f <- function(r) implement.re.2(r, cost = cost, dcost = dcost, e = e)$payoff
optimize(my.f, lower = 0, upper = 0.5, maximum = TRUE)
}
optimize.e.2 <- function(budget = function(s) s, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e){
# find the best r for a given e
my.f <- function(e) optimize.r.at.e.2(e, budget = budget, cost = cost, dcost = dcost)$objective
optimize(my.f, lower = 0, upper = 1, maximum = TRUE)
}
optimize.re.2 <- function(budget = function(s) s, cost = function(e) 0.1 * e^2, dcost = function(e) 0.2 * e){
# find the best r for a given e
best.e <- optimize.e.2(budget = budget)$maximum
best.r <- optimize.r.at.e.2(e = best.e, budget = budget, cost = cost, dcost = dcost)$maximum
ttt <- implement.re.2(r = best.r, e = best.e, budget = budget)
best.contract <- ttt$contract
payoff <- ttt$payoff
my.hessian <- ttt$hessian
return(list(r = best.r, e = best.e, contract = best.contract, payoff = payoff, hessian = my.hessian))
}
plot.all.contracts <- function(do.print = F) {
if (do.print) {
pdf(file = "C:/Users/krgross/Documents/Projects/science-contract/figures/optimal-contracts-cts-effort.pdf", width = 5, height = 4)
}
par(mar = c(5, 4, 1, 1), las = 1)
## binary effort
plot.contracts(add.legend = F, do.print = F)
## cts effort model 1
contract.sb <- optimize.re()$contract$root
u0.sb <- contract.sb[1]
a.sb  <- contract.sb[2]
b.sb  <- contract.sb[3]
h <- function(u) u^2
u <- function(v, u0, a, b) ifelse(v > 0, a + b * v, u0)
u.sb <- function(v) u(v, u0.sb, a.sb, b.sb)
u.sp <- function(v) u(v, u0.sp, a.sp, b.sp)
v.vals <- seq(from = 1e-2, to = 1, length = 100)
# wages vs v
lines(v.vals, h(u.sb(v.vals)), lty = "dotdash")
points(0, a.sb^2, pch = 2, xpd = T)
points(0, h(u.sb(0)), pch = 17, xpd = T)
## cts effort model 2
contract.sb <- optimize.re.2()$contract$root
u0.sb <- contract.sb[1]
a.sb  <- contract.sb[2]
b.sb  <- contract.sb[3]
# wages vs v
lines(v.vals, h(u.sb(v.vals)), lty = "longdash")
points(0, a.sb^2, pch = 6, xpd = T)
points(0, h(u.sb(0)), pch = 25, col = "black", bg = "black", xpd = T)
legend("topleft", leg = c("community's contract, model I", "community's contract, model II",
"community's contract, model III", "planner's contract"),
lty = c("solid", "dotdash", "longdash", "dashed"), col = c("black", "black", "black", "blue"),
pt.bg = c("black", "black", "black", "blue"),
pch = c(16, 17, 25, 16), bty = "n")
if (do.print) {
dev.off()
}
}
optimize.r()
.35/.53
sample(18)
sample(18)
1870.32-60.93-130-36.23+5518.26
getwd()
setwd("GitHub/st512-course-notes/")
bookdown::preview_chapter("08-BlockedDesigns.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("08-BlockedDesigns.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("08-BlockedDesigns.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("08-BlockedDesigns.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
elephant <- read.table("data/elephant.txt", head = T)
head(elephant)
with(elephant, plot(matings ~ age))
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
new.data <- data.frame(age = seq(from = min(elephant$age),
to   = max(elephant$age),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm1$fit, col = "red")
# add lines for standard errors
lines(x   = new.data$age,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
fm2 <- glm(matings ~ age, family = poisson(link = "identity"), data = elephant)
summary(fm2)
predict.fm2 <- predict(fm2, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm2$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit - 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "deviance"),
xlab = "age",
ylab = "Deviance residuals")
abline(h = 0, lty = "dashed")
fm3 <- glm(matings ~ age, family = quasipoisson(link = "identity"), data = elephant)
summary(fm3)
predict.fm3 <- predict(fm3, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm3$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm3$fit + qt(0.025, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm3$fit + qt(0.975, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
require(MASS)
fm4 <- glm.nb(matings ~ age, link = identity, data = elephant)
summary(fm4)
predict.fm4 <- predict(fm4, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm4$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm4$fit + 1.96 * predict.fm4$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm4$fit - 1.96 * predict.fm4$se.fit,
col = "blue",
lty = "dashed")
boar <- read.table("data/boar.txt", head = T)
# remove incomplete records
boar <- na.omit(boar)
# convert sex to a factor
boar$SEX <- as.factor(boar$SEX)
names(boar) <- c("tb", "sex", "age", "length")
summary(boar)
fm1 <- glm(tb ~ length, family = binomial(link = "logit"), data = boar)
summary(fm1)
with(boar, plot(tb ~ length))
# add a line for the fitted probabilities of tb
new.data <- data.frame(length = seq(from = min(boar$length),
to   = max(boar$length),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
lines(x = new.data$length, y = predict.fm1$fit, col = "red")
# add lines for standard errors
# use critical value from z distribution here because
# the scale parameter is not estimated
lines(x   = new.data$length,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$length,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
# probit link
fm1a <- glm(tb ~ length, family = binomial(link = "probit"), data = boar)
# complementary log-log link
fm1b <- glm(tb ~ length, family = binomial(link = "cloglog"), data = boar)
AIC(fm1, fm1a, fm1b)
# make a plot to compare the fits with the different links
predict.fm1a <- predict(fm1a, newdata = new.data, type = "response", se.fit = TRUE)
predict.fm1b <- predict(fm1b, newdata = new.data, type = "response", se.fit = TRUE)
with(boar, plot(tb ~ length))
lines(x = new.data$length, y = predict.fm1$fit, col = "red", lwd = 2)
lines(x = new.data$length, y = predict.fm1a$fit, col = "blue", lwd = 2)
lines(x = new.data$length, y = predict.fm1b$fit, col = "forestgreen", lwd = 2)
legend("left",
leg = c("logit", "probit", "cloglog"),
col = c("red", "blue", "forestgreen"),
pch = 16)
# fit a model with sex, age (as a categorical predictor) and their interaction
fm2 <- glm(tb ~ length + sex * as.factor(age),
family = binomial,
data = boar)
summary(fm2)
with(boar, table(tb, age, sex))
# fit a model with sex, age (as a categorical predictor) and their interaction
fm3 <- glm(tb ~ length + sex + as.factor(age),
family = binomial,
data = boar)
summary(fm3)
moth <- read.table("data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
fm1 <- glm(cbind(removed, placed - removed) ~ morph * distance,
family = binomial(link = "logit"),
data = moth)
summary(fm1)
fm1q <- glm(cbind(removed, placed - removed) ~ morph * distance,
family = quasibinomial(link = "logit"),
data = moth)
summary(fm1q)
plot(x = moth$distance,
y = residuals(fm1q, type = "deviance"),
xlab = "distance",
ylab = "Deviance residuals")
abline(h = 0, lty = "dashed")
bookdown::preview_chapter("04-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
getwd90
getwd()
bookdown::preview_chapter("04-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("04-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("car")
install.packages("SASmarkdown")
getwd()
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("emdbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("R2jags")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("hexbin")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("rstanarm")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("Sleuth2")
install.packages("Sleuth2")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("plotly")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("lmerTest")
bookdown::preview_chapter("06-HierarchicalModels.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
install.packages("pscl")
install.packages("VGAM")
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("08-GEEandGLMMandGAMM.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
