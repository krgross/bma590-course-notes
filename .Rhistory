sd.vals.nb2 <- sqrt(mu.vals * (1 + 1 / phi.mle.alt))
plot(mu.vals, sd.vals.nb1, xlab = "mean", ylab = "SD", type = "l", col = "blue")
lines(mu.vals, sd.vals.nb2, col = "red")
(aic.alt <- 2 * fir.alt$value + 2 * 3)
.2*.9/(,2*,9+.8*.005)
.2*.9/(.2*.9+.8*.005)
162 * .65
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
l.vals <- seq(from = 0, to = 2, length = 200)
plot(l.vals, dgamma(l.vals, shape = 197, rate = 281), type = "l")
lines(l.vals, dgamma(l.vals, shape = 1, rate = 1), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
197 /281
qgamma(0.5, shape = 197, rate = 281)
optimize(f = function(x) dgamma(x, shape = 197, rate = 281), interval = c(0.5, 1), maximum = TRUE)
qgamma(c(0.025, 0.975), shape = 197, rate = 281)
diff.in.pdf <- function(x){
upper <- qgamma(p = x, shape = 197, rate = 281)
lower <- qgamma(p = x - .95, shape = 197, rate = 281)
dgamma(upper, shape = 197, rate = 281) - dgamma(lower, shape = 197, rate = 281)
}
(upper.qtile <- uniroot(diff.in.pdf, interval = c(0.95, 1))$root)
(hpd.ci <- qgamma(p = c(upper.qtile - .95, upper.qtile), shape = 197, rate = 281))
(central.ci <- qgamma(c(0.025, 0.975), shape = 197, rate = 281))
abline(v = central.ci, lty = "dashed")
pgamma(2/3, shape = 197, rate = 281, lower.tail = FALSE)
plot(l.vals, dgamma(l.vals, shape = 196 + 50, rate = 100 + 280), type = "l",
xlab = expression(lambda), ylab = "")
lines(l.vals, dgamma(l.vals, shape = 50, rate = 100), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
source('~/Teaching/bma590/bma590-fall21/r/class08.R')
175 / 449
449 * .4
180 / 449
185/456
456*.4
deer <- read.csv("~/Teaching/data/deer.txt", sep="")
View(deer)
fm1 <- with(deer, lm(deer.total ~ log(house.dens) + log(pop.dens)))
summary(fm1)
fm2 <- with(deer, lm(deer.total ~ house.dens + pop.dens)
)
summary(fm2)
fm3 <- with(deer, lm(deer.total ~ log(pop.dens)))
plot(resid$fm3 ~ log(deer$house.dens))
plot(fm3$residuals ~ log(deer$house.dens))
fm4 <- lm(fm3$residuals ~ log(deer$house.dens))
summary(fm4)
summary(fm3)
fm5 <- with(deer, lm(deer.total ~ log(house.dens)))
summary(fm5)
fm6 <- lm(fm5$residuals ~ log(deer$road.dens))
fm6 <- lm(fm5$residuals ~ log(deer$pop.dens))
summary(fm6)
pop.only <- lm(deer.take ~ log(pop.dens) + rd.dens, data = deer)
pop.only <- lm(deer.total ~ log(pop.dens) + rd.dens, data = deer)
house.only <- lm(deer.total ~ log(house.dens) + rd.dens, data = deer)
summary(pop.only)
summary(house.only)
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
require(R2jags)
horse.model <- function() {
for (j in 1:J) {             # J = 280, number of data points
y[j] ~ dpois (lambda)      # data model:  the likelihood
}
lambda ~ dgamma (0.01, 0.01) # prior
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
}
jags.data <- list(y = horse$deaths, J = length(horse$deaths))
jags.params <- c("lambda")
jags.inits <- function(){
list("lambda" = rgamma(0.01, 0.01))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = horse.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
median(mcmc.output$lambda)
quantile(mcmc.output$lambda, c(.025, .975))
median(mcmc.output$lambda)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
densityplot(mcmc.output)
densityplot(mcmc.output$lambda)
rm(list = ls())
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
require(R2jags)
horse.model <- function() {
for (j in 1:J) {             # J = 280, number of data points
y[j] ~ dpois (lambda)      # data model:  the likelihood
}
lambda ~ dgamma (0.01, 0.01) # prior
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
}
jags.data <- list(y = horse$deaths, J = length(horse$deaths))
jags.params <- c("lambda")
jags.inits <- function(){
list("lambda" = rgamma(0.01, 0.01))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = horse.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
rm(list = ls())
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
cor(mcmc.output)
cor(mcmc.output[, -c(3:4)])
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
cor(mcmc.output)
cor(mcmc.output[, -c(3:4)])
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
rf <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
library(hexbin)
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
with(jagsfit$BUGSoutput$sims.list, hexbinplot(b1 ~ b0, colramp = rf))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
cor(mcmc.output)
cor(mcmc.output[, -c(3:4)])
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
jags.data <- list(y = cricket$chirps,
x = cricket$temp.ctr,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
library(hexbin)
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
with(jagsfit$BUGSoutput$sims.list, hexbinplot(b1 ~ b0, colramp = rf))
with(jagsfit$BUGSoutput$sims.list, cor(b0, b1))
require(rstanarm)
stanarm.cricket.fit <- stan_glm(chirps ~ temp.ctr, data = cricket, family = gaussian, seed = 1)
print(stanarm.cricket.fit, digits = 3)
rm(list = ls())
require(R2jags)
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
str(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
head(mcmc.output)
medain(mcmc.output$sigma)
median(mcmc.output$sigma)
plot(density(mcmc.output$b1))
plot(density(mcmc.output$sigma))
plot(chirps ~ temperature, data = cricket, type = "n")
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.25))
}
with(cricket, points(chirps ~ temperature, pch = 16))
avg.chirps.85 <- with(mcmc.output, b0 + b1 * 85)
summary(avg.chirps.85)
quantile(avg.chirps.85, probs = c(.025, 0.975))
plot(density(avg.chirps.85))
n.sims <- nrow(mcmc.output)
new.errors <- with(mcmc.output, rnorm(n.sims, mean = 0, sd = sigma))
new.chirps.85 <- with(mcmc.output, b0 + b1 * 85) + new.errors
plot(density(new.chirps.85))
summary(new.chirps.85)
quantile(new.chirps.85, probs = c(.025, 0.975))
rm(list = ls())
require(R2jags)
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
str(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
plot(density(mcmc.output$b1))
head(mcmc.output)
plot(chirps ~ temperature, data = cricket, type = "n")
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.25))
}
with(cricket, points(chirps ~ temperature, pch = 16))
?rbeta
source('~/Teaching/bma590/bma590-fall21/r/class11.R')
## download the data from the book's website
isit <- read.table("../data/ISIT.txt", head = T)
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
## download the data from the book's website
isit <- read.table("data/ISIT.txt", head = T)
## extract the data from station 16
st16 <- subset(isit, Station == 16)
## retain just the variables that we want, and rename
st16 <- st16[, c("SampleDepth", "Sources")]
names(st16) <- c("depth", "sources")
with(st16, plot(sources ~ depth))
## fit a loess smoother using the default settings
st16.lo <- loess(sources ~ depth, data = st16)
st16.lo <- loess(sources ~ depth, data = st16)
st16.lo <- loess(sources ~ depth, data = st16)
summary(st16.lo)
depth.vals <- with(st16, seq(from   = min(depth),
to     = max(depth),
length = 100))
st16.fit <- predict(object  = st16.lo,
newdata = depth.vals,
se      = TRUE)
lines(x = depth.vals, y = st16.fit$fit, col = "blue")
depth.vals <- with(st16, seq(from   = min(depth),
to     = max(depth),
length = 100))
st16.fit <- predict(object  = st16.lo,
newdata = depth.vals,
se      = TRUE)
with(st16, plot(sources ~ depth))
lines(x = depth.vals, y = st16.fit$fit, col = "blue")
# add 95% error bars
lines(x   = depth.vals,
y   = st16.fit$fit + st16.fit$se.fit * qt(p = .975, df = st16.fit$df),
col = "blue",
lty = "dashed")
lines(x   = depth.vals,
y   = st16.fit$fit - st16.fit$se.fit * qt(p = .975, df = st16.fit$df),
col = "blue",
lty = "dashed")
## see what the fit returns; maybe the residuals are already there
names(st16.lo)  # they are!
plot(st16.lo$residuals ~ st16$depth)
abline(h = 0, lty = "dotted")
PlotLoessFit <- function(x, y, return.fit = FALSE, ...){
# Caluclates a loess fit with the 'loess' function, and makes a plot
#
# Args:
#   x: predictor
#   y: response
#   return.fit: logical
#   ...: Optional arguments to loess
#
# Returns:
#   the loess fit
my.lo <- loess(y ~ x, ...)
x.vals <- seq(from = min(x), to = max(x), length = 100)
my.fit <- predict(object  = my.lo,
newdata = x.vals,
se      = TRUE)
plot(x, y)
lines(x = x.vals, y = my.fit$fit, col = "blue")
lines(x   = x.vals,
y   = my.fit$fit + my.fit$se.fit * qt(p = .975, df = my.fit$df),
col = "blue",
lty = "dashed")
lines(x   = x.vals,
y   = my.fit$fit - my.fit$se.fit * qt(p = .975, df = my.fit$df),
col = "blue",
lty = "dashed")
if (return.fit) {
return(my.lo)
}
}
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.5)
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.25)
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.1)
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.25, degree = 1)
library(mgcv)
st16.spline <- gam(sources ~ s(depth), data = st16)
plot(st16.spline, se = TRUE)  # note that the plot does not include the intercept
summary(st16.spline)
with(st16, plot(sources ~ depth))
st16.fit <- predict(st16.spline,
newdata = data.frame(depth = depth.vals),
se      = TRUE)
lines(x = depth.vals, y = st16.fit$fit)
## add +/- 2 SE following Zuur; this is only approximate.
## should probably use a critical value from a t-dist with n - edf df, that is, 51 - 9.81 = 41.19 df
lines(x = depth.vals, y = st16.fit$fit + 2 * st16.fit$se.fit, lty = "dashed")
lines(x = depth.vals, y = st16.fit$fit - 2 * st16.fit$se.fit, lty = "dashed")
AIC(st16.spline)
rm(list = ls())
require(mgcv)
bird <- read.table("data/Loyn.txt", head = T)
summary(bird)
# get rid of the 'Site' variable
bird <- bird[, -1]
# log-transform area, distance, ldistance
bird$L.AREA <- log(bird$AREA)
bird$L.DIST <- log(bird$DIST)
bird$L.LDIST <- log(bird$LDIST)
# change YR.ISOL to years since isolation (study was published in 1987)
bird$YR.ISOL <- 1987 - bird$YR.ISOL
# keep the only the variables we want
bird <- bird[, c("ABUND", "L.AREA", "L.DIST", "L.LDIST", "YR.ISOL", "ALT", "GRAZE")]
bird.lm1 <- lm(ABUND ~ L.AREA + L.DIST + L.LDIST + YR.ISOL + GRAZE + ALT, data = bird)
summary(bird.lm1)
bird.lm2 <- lm(ABUND ~ L.AREA + YR.ISOL + GRAZE, data = bird)
plot(residuals(bird.lm2) ~ bird$L.AREA)
abline(h = 0, lty = "dashed")
bird.am1 <- gam(ABUND ~ s(L.AREA) + s(L.DIST) + s(L.LDIST) + s(YR.ISOL) + GRAZE + s(ALT), data = bird)
summary(bird.am1)
plot(bird.am1)
bird.am1 <- mgcv::gam(ABUND ~ s(L.AREA) + s(L.DIST) + s(L.LDIST) + s(YR.ISOL) + GRAZE + s(ALT), data = bird)
summary(bird.am1)
plot(bird.am1)
bird.am2 <- gam(ABUND ~ s(L.AREA) + GRAZE, data = bird)
summary(bird.am2)
plot(bird.am2)
bird$fGRAZE <- as.factor(bird$GRAZE)
summary(bird)
bird.am3 <- gam(ABUND ~ s(L.AREA) + fGRAZE, data = bird)
summary(bird.am3)
AIC(bird.am2)
AIC(bird.am3)
with(bird, contrasts(fGRAZE))
bird.am4 <- gam(ABUND ~ s(L.AREA), data = bird)
plot(x = bird$GRAZE, y = bird.am4$residuals)
abline(h = 0, lty = "dashed")
bird.am5 <- gam(ABUND ~ s(L.AREA, k = 5, fx = TRUE) + GRAZE, data = bird)
bird.am6 <- gam(ABUND ~ s(L.AREA, k = 5, fx = TRUE) + fGRAZE, data = bird)
anova(bird.am5, bird.am6, test = "F")
summary(bird.am5)
bird.am5 <- gam(ABUND ~ s(L.AREA, k = 4, fx = TRUE) + GRAZE, data = bird)
bird.am6 <- gam(ABUND ~ s(L.AREA, k = 4, fx = TRUE) + fGRAZE, data = bird)
anova(bird.am5, bird.am6, test = "F")
bird.am5 <- gam(ABUND ~ s(L.AREA, k = 5, fx = TRUE) + GRAZE, data = bird)
bird.am6 <- gam(ABUND ~ s(L.AREA, k = 5, fx = TRUE) + fGRAZE, data = bird)
anova(bird.am5, bird.am6, test = "F")
bird.am5 <- gam(ABUND ~ s(L.AREA, k = 4, fx = TRUE) + GRAZE, data = bird)
bird.am6 <- gam(ABUND ~ s(L.AREA, k = 4, fx = TRUE) + fGRAZE, data = bird)
anova(bird.am5, bird.am6, test = "F")
bird.am3 <- gam(ABUND ~ s(L.AREA) + fGRAZE, data = bird)
plot(bird.am3)
summary(bird.am3)
rm(list = ls())
require(mgcv)
bird <- read.table("data/Loyn.txt", head = T)
summary(bird)
# get rid of the 'Site' variable; it is redundant with the row label
bird <- bird[, -1]
# log-transform area, distance, ldistance, to remove right-skew
bird$L.AREA <- log(bird$AREA)
bird$L.DIST <- log(bird$DIST)
bird$L.LDIST <- log(bird$LDIST)
# change YR.ISOL to years since isolation (study was published in 1987)
bird$YR.ISOL <- 1987 - bird$YR.ISOL
# keep the only the variables we want
bird <- bird[, c("ABUND", "L.AREA", "L.DIST", "L.LDIST", "YR.ISOL", "ALT", "GRAZE")]
summary(bird)
bird.am1 <- mgcv::gam(ABUND ~ s(L.AREA) + s(L.DIST) + s(L.LDIST) + s(YR.ISOL) + GRAZE + s(ALT), data = bird)
summary(bird.am1)
