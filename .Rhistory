par(mfrow = c(1, 1))
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")
lines(fit.vals.alt ~ dbh.vals, col = "red")
(aic.alt <- 2 * fir.alt$value + 2 * 3)
mu.vals <- seq(from = 0, to = max(fit.vals), length = 100)
sd.vals.nb1 <- sqrt(mu.vals + mu.vals ^ 2 / k.mle)
sd.vals.nb2 <- sqrt(mu.vals * (1 + 1 / k.mle.alt))
plot(mu.vals, sd.vals.nb1, xlab = "mean", ylab = "SD", type = "l", col = "blue")
lines(mu.vals, sd.vals.nb2, col = "red")
getwd()
setwd("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall23/homework/hwk2/")
knitr::opts_chunk$set(echo = TRUE)
# load the data
cricket <- read.csv("../../data/cricket.csv", head = T)
# write the negative log likelihood function
cricket.neg.ll <- function(params){
b0 <- params[1]
b1 <- params[2]
sd.eps <- params[3]
-1 * sum(dnorm(cricket$chirps, mean = b0 + b1 * cricket$temperature, sd = sd.eps, log = TRUE))
}
# obtain the MLEs
cricket.mle <- optim(par = c(-0.3, 0.2, 1),
fn  = cricket.neg.ll)
# now find the Hessian
(D2 <- numDeriv::hessian(func = cricket.neg.ll, x = cricket.mle$par))
(var.matrix <- solve(D2))
round(cov2cor(var.matrix), 3)
sqrt(diag(var.matrix))
fm1 <- lm(chirps ~ temperature, data = cricket)
summary(fm1)
vcov(fm1)
fm1 <- lm(chirps ~ temperature, data = cricket)
summary(fm1)
vcov(fm1)
cov2cor(vcov(fm1))
fm1 <- lm(chirps ~ temperature, data = cricket)
knitr::opts_chunk$set(echo = TRUE)
# load the data
library(emdbook)
data("ReedfrogFuncresp")
# rename something shorter
frog <- ReedfrogFuncresp
rm(ReedfrogFuncresp)
# write the negative log likelihood function
frog.neg.ll <- function(params){
a <- params[1]
h <- params[2]
prob.vals <- a / (1 + a * h * frog$Initial)
ll.vals <- dbinom(frog$Killed, size = frog$Initial, prob = prob.vals, log = TRUE)
-1 * sum(ll.vals)
}
# obtain the MLEs
frog.mle <- optim(par = c(0.5, 1/40),
fn  = frog.neg.ll)
a.mle <- frog.mle$par[1]
h.mle <- frog.mle$par[2]
# build the profile likelihood function
profile.ll <- function(my.h) {
# Calculate the minimum log likelihood value for a given value of a, the attack rate
my.ll <- function(a) frog.neg.ll(c(a, my.h))
my.profile <- optimize(f = my.ll, interval = c(0.3, 0.8), maximum = FALSE)
my.profile$objective
}
# calculate and plot the likelihood
h.values <- seq(from = 0.001, to = 0.04, by = 0.001)
h.profile <- double(length = length(h.values))
for (i in 1:length(h.values)) {
h.profile[i] <- profile.ll(h.values[i])
}
plot(x = h.values, y = h.profile, xlab = "h", ylab = "negative log-likelihood", type = "l")
# find limits of a 95% confidence interval
lower <- uniroot(f = function(x) profile.ll(h.mle) + qchisq(0.95, df = 1) / 2 - profile.ll(x) ,
interval = c(0.001, h.mle))
upper <- uniroot(f = function(x) profile.ll(h.mle) + qchisq(0.95, df = 1) / 2 - profile.ll(x) ,
interval = c(h.mle, 0.04))
lower$root
upper$root
# 90% confidence interval
lower <- uniroot(f = function(x) profile.ll(h.mle) + qchisq(0.90, df = 1) / 2 - profile.ll(x) ,
interval = c(0.001, h.mle))
upper <- uniroot(f = function(x) profile.ll(h.mle) + qchisq(0.90, df = 1) / 2 - profile.ll(x) ,
interval = c(h.mle, 0.04))
lower$root
upper$root
# load the data
cricket <- read.csv("../../data/cricket.csv", head = T)
# write the negative log likelihood function
cricket.neg.ll <- function(params){
b0 <- params[1]
b1 <- params[2]
sd.eps <- params[3]
-1 * sum(dnorm(cricket$chirps, mean = b0 + b1 * cricket$temperature, sd = sd.eps, log = TRUE))
}
# obtain the MLEs
cricket.mle <- optim(par = c(-0.3, 0.2, 1),
fn  = cricket.neg.ll)
# now find the Hessian
(D2 <- numDeriv::hessian(func = cricket.neg.ll, x = cricket.mle$par))
(var.matrix <- solve(D2))
round(cov2cor(var.matrix), 3)
sqrt(diag(var.matrix))
fm1 <- lm(chirps ~ temperature, data = cricket)
vcov(fm1)
cov2cor(vcov(fm1))
round(sqrt(var.matrix[2,2], 3))
round(sqrt(var.matrix[2,2]), 3)
round(sqrt(vcov(fm1[2,2]), 4)
)
round(sqrt(vcov(fm1)[2,2]), 4)
round(sqrt(var.matrix[2,2]), 4)
(sqrt(var.matrix[2,2]) - sqrt(vcov(fm1)[2,2])) / sqrt(vcov(fm1)[2,2])
round(100 * (sqrt(vcov(fm1)[2,2]) - sqrt(var.matrix[2,2])) / sqrt(vcov(fm1)[2,2]), 1)
getwd()
?round
require(emdbook)
data("FirDBHFec")
fir <- FirDBHFec
rm(FirDBHFec)
names(fir)
fir <- fir[, c("WAVE_NON", "DBH", "TOTCONES")]
names(fir) <- c("wave", "dbh", "cones")
summary(fir)
head(fir)
fir <- na.omit(fir)
summary(fir)
with(fir, table(cones == round(cones)))
# round the non-integral values
fir$cones <- round(fir$cones)
# check
with(fir, table(cones == round(cones)))
par(mfrow = c(1, 2))
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
summary(fi)
summary(fir)
write.csv("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall23/data/fir-wave.csv", quote = F, row.names = F)
write.csv(subset(fir, wave == "w"), C:/Users/krgross/Documents/Teaching/bma590/bma590-fall23/data/fir-wave.csv", quote = F, row.names = F)
write.csv(subset(fir, wave == "w"), "C:/Users/krgross/Documents/Teaching/bma590/bma590-fall23/data/fir-wave.csv", quote = F, row.names = F)
getwd()
fir <- read.csv("../../data/fir-wave.csv", head = T)
summary(fir)
fir <- read.csv("../../data/fir-wave.csv", head = T, stringsAsFactors = T)
summary(fir)
fir <- read.csv("../../data/fir-wave.csv", head = T, stringsAsFactors = T)
fir.neg.ll.full <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * x^b
ll.values <- dnbinom(y, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
# fit full model
(fir.full <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
fir <- read.csv("../../data/fir-wave.csv", head = T, stringsAsFactors = T)
fir.neg.ll.full <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * x^b
ll.values <- dnbinom(y, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
# fit full model
(fir.full <- optim(f   = fir.neg.ll.full,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
## fit reduced model with b = 1
fig.neg.ll.reduced <- function(parms, x, y) fir.neg.ll.full(c(parms[1], 1, parms[2]), x, y)
(fir.reduced <- optim(f   = fir.neg.ll.reduced,
par = c(a = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
fir <- read.csv("../../data/fir-wave.csv", head = T, stringsAsFactors = T)
fir.neg.ll.full <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * x^b
ll.values <- dnbinom(y, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
# fit full model
(fir.full <- optim(f   = fir.neg.ll.full,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
## fit reduced model with b = 1
fir.neg.ll.reduced <- function(parms, x, y) fir.neg.ll.full(c(parms[1], 1, parms[2]), x, y)
(fir.reduced <- optim(f   = fir.neg.ll.reduced,
par = c(a = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
# Plot the reduced model
with(fir, plot(cones ~ dbh))
abline(a = fir.reduced$par[1])
fir <- read.csv("../../data/fir-wave.csv", head = T, stringsAsFactors = T)
fir.neg.ll.full <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * x^b
ll.values <- dnbinom(y, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
# fit full model
(fir.full <- optim(f   = fir.neg.ll.full,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
## fit reduced model with b = 1
fir.neg.ll.reduced <- function(parms, x, y) fir.neg.ll.full(c(parms[1], 1, parms[2]), x, y)
(fir.reduced <- optim(f   = fir.neg.ll.reduced,
par = c(a = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
# Plot the reduced model
with(fir, plot(cones ~ dbh))
abline(a = fir.reduced$par[1], b = 1)
# LRT test
(lrt.stat <- 2 * (fir.reduced$value - fir.full$value))  # compute the likelihood ratio test statistic
(lrt.pvalue <- pchisq(q = lrt.stat, df = 1, lower.tail = FALSE))  # calculate the p-vlaue
(.97)^2
knitr::opts_chunk$set(echo = TRUE)
# load the data
library(emdbook)
data("ReedfrogFuncresp")
# rename something shorter
frog <- ReedfrogFuncresp
rm(ReedfrogFuncresp)
require(R2jags)
frog.model <- function() {
for (j in 1:J) {                  # J = number of data points
y[j] ~ dbin (p[j], n[j])        # data model:  the likelihood
p[j] <- a / (1 + a * h * n[j])   # probability that an individual tadpole was eaten
}
a ~ dunif (0, 1)                   # vague prior for attack rate
h ~ dexp (14)                     # prior for handling time, prior mean is 1 day (= 1 / 14 of a fortnight)
}
jags.data <- list(y = frog$Killed,
n = frog$Initial,
J = nrow(frog))
jags.params <- c("a", "h")
jags.inits <- function(){
list("a" = 0.5, "h" = 1)
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = frog.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
cor(mcmc.output)
names(mcmc.output)
plot(Killed ~ Initial, data = frog, type = "n")
init.values <- with(frog, seq(from   = min(Initial),
to     = max(Initial),
length = 100))
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
pred.values <- with(mcmc.output, a[i] * init.values / (1 + a[i] * h[i] * init.values))
lines(x = init.values, y = pred.values, col = "deepskyblue")
}
# add a line to show the posterior mean trend
a.mean <- mean(mcmc.output$a)
h.mean <- mean(mcmc.output.h)
plot(Killed ~ Initial, data = frog, type = "n")
init.values <- with(frog, seq(from   = min(Initial),
to     = max(Initial),
length = 100))
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
pred.values <- with(mcmc.output, a[i] * init.values / (1 + a[i] * h[i] * init.values))
lines(x = init.values, y = pred.values, col = "deepskyblue")
}
# add a line to show the posterior mean trend
a.mean <- mean(mcmc.output$a)
h.mean <- mean(mcmc.output$h)
lines(x = init.values, y = a.mean * init.values / (1 + a.mean * h.mean * init.values), col = "violet", lwd = 2)
with(frog, points(Killed ~ Initial, pch = 16))
plot(Killed ~ Initial, data = frog, type = "n")
init.values <- with(frog, seq(from   = min(Initial),
to     = max(Initial),
length = 100))
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
pred.values <- with(mcmc.output, a[i] * init.values / (1 + a[i] * h[i] * init.values))
lines(x = init.values, y = pred.values, col = "deepskyblue")
}
# add a line to show the posterior mean trend
a.mean <- mean(mcmc.output$a)
h.mean <- mean(mcmc.output$h)
lines(x = init.values, y = a.mean * init.values / (1 + a.mean * h.mean * init.values), col = "sienna3", lwd = 2)
with(frog, points(Killed ~ Initial, pch = 16))
plot(Killed ~ Initial, data = frog, type = "n")
init.values <- with(frog, seq(from   = min(Initial),
to     = max(Initial),
length = 100))
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
pred.values <- with(mcmc.output, a[i] * init.values / (1 + a[i] * h[i] * init.values))
lines(x = init.values, y = pred.values, col = "deepskyblue")
}
# add a line to show the posterior mean trend
a.mean <- mean(mcmc.output$a)
h.mean <- mean(mcmc.output$h)
lines(x = init.values, y = a.mean * init.values / (1 + a.mean * h.mean * init.values), col = "purple3", lwd = 2)
with(frog, points(Killed ~ Initial, pch = 16))
knitr::opts_chunk$set(echo = TRUE)
# load the data
library(emdbook)
data("ReedfrogFuncresp")
# rename something shorter
frog <- ReedfrogFuncresp
rm(ReedfrogFuncresp)
require(R2jags)
frog.model <- function() {
for (j in 1:J) {                  # J = number of data points
y[j] ~ dbin (p[j], n[j])        # data model:  the likelihood
p[j] <- a / (1 + a * h * n[j])   # probability that an individual tadpole was eaten
}
a ~ dunif (0, 1)                   # vague prior for attack rate
h ~ dexp (14)                     # prior for handling time, prior mean is 1 day (= 1 / 14 of a fortnight)
}
jags.data <- list(y = frog$Killed,
n = frog$Initial,
J = nrow(frog))
jags.params <- c("a", "h")
jags.inits <- function(){
list("a" = 0.5, "h" = 1)
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = frog.model,
n.chains           = 3,
n.iter             = 5000,
jags.seed          = 1)
print(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
cor(mcmc.output)
with(mcmc.output, plot(a, h))
summary(frog)
with(frog, sum(Killed) / Sum(Initial))
with(frog, sum(Killed) / sum(Initial))
abline(v = .3475)
library(MASS)
data(mcycle)
summary(mcycle)
with(mcycle, plot(accel ~ times))
?mcycle
library(splines)
fm1 <- lm(accel ~ bs(times, df = 8), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
summary(fm1)
with(mcycle, plot(accel ~ times))
library(splines)
fm1 <- lm(accel ~ bs(times, df = 8), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, knots = seq(from = 13, to = 52, by = 3)), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, knots = seq(from = 13, to = 52, by = 6)), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ bs(times, knots = seq(from = 13, to = 52, by = 6)), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ bs(times, knots = c(1, seq(from = 13, to = 52, by = 6))), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ bs(times, knots = c(4, seq(from = 13, to = 52, by = 6))), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ bs(times, df = 10), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, df = 10), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, df = 12), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, df = 9), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, df = 8), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
library(splines)
fm1 <- lm(accel ~ ns(times, df = 9), data = mcycle)
t.vals <- seq(from = min(mcycle$times), to = max(mcycle$times), length = 100)
fm1.pred <- predict(fm1, newdata = list(times = t.vals), se = T)
with(mcycle, plot(accel ~ times))
lines(t.vals, fm1.pred$fit, lwd = 2, col = "red")
lines(t.vals, fm1.pred$fit + qt(0.975, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
lines(t.vals, fm1.pred$fit + qt(0.025, df = 43) * fm1.pred$se, lty = "dashed", col = "red")
## plot the residuals
plot(fm1$residuals ~ mcycle$times, xlab = "ms after impact", ylab = "residuals"))
## plot the residuals
plot(fm1$residuals ~ mcycle$times, xlab = "ms after impact", ylab = "residuals")
abline(h = 0, lty = "dotted")
require(mgcv)
m.spline <- gam(accel ~ s(times), data = mcycle)
summary(m.spline)
## make a plot that includes both the points and the fit
with(mcycle, plot(accel ~ times, xlab = "ms after impact", ylab = "acceleration", main = "Smoothing spline fit"))
m.fit <- predict(m.spline,
newdata = data.frame(times = t.vals),
se      = TRUE)
lines(x = t.vals, y = m.fit$fit)
## add +/- 2 SE following Zuur; this is only approximate.
lines(x = t.vals, y = m.fit$fit + 2 * m.fit$se.fit, lty = "dashed")
lines(x = t.vals, y = m.fit$fit - 2 * m.fit$se.fit, lty = "dashed")
## residual plot
plot(m.spline$residuals ~ mcycle$times, xlab = "ms after impact", ylab = "residuals")
abline(h = 0, lty = "dashed")
?dgamma
dgamma(0, shape = .01, rate = .01)
dgamma(0, shape = 1, rate = 1)
curve(function(x) dgamma(x, 1, 1))
?curve
gamma_pdf <- function(x) dgamma(x, .01, .01)
curve(gamma_pdf, from = 0, to = 1)
abline(v = 0)
gamma_pdf <- function(x) dgamma(x, .1, .1)
curve(gamma_pdf, from = 0, to = 1)
gamma_pdf <- function(x) dgamma(x, .1, .1)
abline(v = 0)
gamma_pdf <- function(x) dgamma(x, 1, 1)
abline(v = 0)
curve(gamma_pdf, from = 0, to = 1)
abline(v = 0)
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::preview_chapter("03-BayesianComputation", "bookdown::gitbook")
bookdown::preview_chapter("03-BayesianIntro.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("03-BayesianIntro.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("03-BayesianIntro.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("03-BayesianIntro.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
