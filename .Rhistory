abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0, col = "blue", lty = "dotted")
}
# we want a model where the variance of the random beach effects differs between low vs. high exposure beaches.
# how do we do that??
fm4 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + fExp + (1 | fBeach), data = rikz)
a0 <- coef(summary(fm4))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm4))[2, 1]  # common slope for all beaches
a1 <- coef(summary(fm4))[3, 1]  # difference in marginal intercepts for high vs low
c.mode <- ranef(fm4)$fBeach
# this code is ugly, but oh well
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
# Repeat for high exposure beaches
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0, col = "blue", lty = "dotted")
}
# we want a model where the variance of the random beach effects differs between low vs. high exposure beaches.
# how do we do that??
#######################
# Model 1: random intercept
#######################
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# highlight beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
# make a plot with a line for each beach
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = a + c.mode[1, i], b = b, col = "red", lty = "dotted")
}
#######################
# Model 1: random intercept
#######################
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# highlight beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
# make a plot with a line for each beach
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = a + c.mode[i, 1], b = b, col = "red", lty = "dotted")
}
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm0 <- lm(Yield ~ 1, data = Dyestuff)          # model with common mean
fm1 <- lm(Yield ~ Batch - 1, data = Dyestuff)  # mean varies by group
anova(fm0, fm1)  # usual F-test for differences among group means
summary(fm1)  # eliminating the intercept gives sample means for each group
require(nlme)
fm2 <- gls(Yield ~ 1, data = Dyestuff,
correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm2)
fm3 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm3)
fixef(fm3)
(batch.conditional.modes <- (fixef(fm3) + ranef(fm3)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
fm3ML <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff, REML = FALSE)
summary(fm3ML)
pr <- profile(fm3ML)
lattice::xyplot(pr)
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = .95)
confint(pr, level = .99)
lattice::splom(pr)
require(lmerTest)
fm4 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm4)
require(R2jags)
dyestuff.model <- function() {
## likelihood
for (j in 1:J) {
y[j]    ~ dnorm(B[batch[j]], tau_eps)  # data distribution
}
## latent variables
for (b in 1:6){
B[b] ~ dnorm(mu, tauB)
}
mu ~ dnorm (0.0, 1E-6)  # prior for the overall mean
tau_eps ~ dgamma (0.01, 0.01)
tauB    ~ dgamma (0.01, 0.01)
sd_eps <- pow(tau_eps, -1/2)
sdB    <- pow(tauB, -1/2)
}
jags.data <- list(y     = Dyestuff$Yield,
batch = as.numeric(Dyestuff$Batch),
J     = nrow(Dyestuff))
jags.params <- c("mu", "sd_eps", "sdB", "B[1]", "B[2]")
jags.inits <- function(){
list("mu" = rnorm(1, .01), "tauB" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = dyestuff.model,
n.chains           = 3,
n.iter             = 1e5)
print(jagsfit)
traceplot(jagsfit)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
data(Dyestuff2)
summary(Dyestuff2)
with(Dyestuff2, stripchart(Yield ~ Batch, pch = 16))
fm5 <- gls(Yield ~ 1, data = Dyestuff2, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm5)
fm6 <- lme4::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
summary(fm6)
rm(list = ls())
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/ZuurDataMixedModelling/RIKZ.txt", head = T)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
rikz$fBeach <- as.factor(rikz$Beach)
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = a + c.mode[i, 1], b = b, col = "red", lty = "dotted")
}
fm2 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 + NAP | fBeach), data = rikz)
summary(fm2)
ranef(fm2)
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm2))[1, 1]
b <- coef(summary(fm2))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm2)$fBeach
abline(a = a + c.mode[1, 1], b = b + c.mode[1, 2], col = "red", lty = "dotted")
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = as.character(1:9))
anova(fm1, fm2)  # could compare REML fits by fitting both models with nlme::lme
fm2a <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach) + (0 + NAP | fBeach), data = rikz)
anova(fm1, fm2a, fm2)
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + fExp + NAP:fExp + (1 | fBeach), data = rikz)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP * fExp + (1 | fBeach), data = rikz)
summary(fm3)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
require(rstanarm)
stan_fm1 <- stan_lmer(formula = Yield ~ 1 + (1 | Batch),
data = Dyestuff,
seed = 1)
prior_summary(stan_fm1)
print(stan_fm1, digits = 2)
summary(stan_fm1,
# pars = c("(Intercept)", "sigma", "Sigma[school:(Intercept),(Intercept)]"),
probs = c(0.025, 0.975),
digits = 2)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm0 <- lm(Yield ~ 1, data = Dyestuff)          # model with common mean
fm1 <- lm(Yield ~ Batch - 1, data = Dyestuff)  # mean varies by group
anova(fm0, fm1)  # usual F-test for differences among group means
summary(fm1)  # eliminating the intercept gives sample means for each group
require(nlme)
fm2 <- gls(Yield ~ 1, data = Dyestuff,
correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm2)
fm3 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm3)
fixef(fm3)
(batch.conditional.modes <- (fixef(fm3) + ranef(fm3)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
data("Wheat2")
summary(Wheat2)
require(nlme)
data("Wheat2")
summary(Wheat2)
with(Wheat2, plot(x = longitude, y = latitude,
pch = as.numeric(Block)))
fm1 <- nlme::gls(yield ~ variety, data = Wheat2)
plot(Variogram(fm1, form = ~ latitude + longitude))
require(plotly)
plot_ly(x = Wheat2$latitude,
y = Wheat2$longitude,
z = resid(fm1),
type = "scatter3d",
mode = "markers",
color = resid(fm1))
fm2 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corSpher(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
print(fm2)
plot(Variogram(fm2, form = ~ latitude + longitude))
plot(Variogram(fm2, form = ~ latitude + longitude, resType = "n"))
fm3 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corGaus(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
print(fm3)
plot(Variogram(fm3, form = ~ latitude + longitude))
plot(Variogram(fm3, form = ~ latitude + longitude, resType = "n"))
anova(fm1, fm2, fm3)
fm4 <- nlme::gls(yield ~ variety + latitude * longitude, data = Wheat2)
print(fm4)
anova(fm4)
plot(Variogram(fm4, form = ~ latitude + longitude))
anova(fm1, fm2, fm3, fm4)
fm3ML <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corGaus(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE),
method = "ML")  # need to supply starting values
fm4ML <- nlme::gls(yield ~ variety + latitude * longitude, data = Wheat2, method = "ML")
fm3ML <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corGaus(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE),
method = "ML")  # need to supply starting values
fm4ML <- nlme::gls(yield ~ variety + latitude * longitude, data = Wheat2, method = "ML")
plot(Variogram(fm4ML, form = ~ latitude + longitude))
anova(fm3ML, fm4ML)
elephant <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/elephant.txt", head = T)
with(elephant, plot(matings ~ age))
fm1 <- glm(matings ~ age, family = poisson, data = elephant)  # log link is the default
a
elephant <- read.table("C:/Users/krgross/Documents/Teaching/bma590/www/data/elephant.txt", head = T)
elephant <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/elephant.txt", head = T)
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
(pseudo.R2 <- 1 - 51.012 / 75.372)
new.data <- data.frame(age = seq(from = min(elephant$age),
to   = max(elephant$age),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm1$fit, col = "red")
lines(x   = new.data$age,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
fm2 <- glm(matings ~ age, family = poisson(link = "identity"), data = elephant)
summary(fm2)
predict.fm2 <- predict(fm2, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm2$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit - 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "deviance"),
xlab = "age",
ylab = "Deviance residuals")
abline(h = 0, lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "pearson"),
xlab = "age",
ylab = "Pearson residuals")
abline(h = 0, lty = "dashed")
glm
?glm
fm3 <- glm(matings ~ age, family = quasipoisson(link = "identity"), data = elephant)
print(fm3)
summary(fm3)
summary(fm2)
sqrt(50/39)
sqrt(50.058/39)
0.04271 / 0.04023
(0.04271 / 0.04023)^2
predict.fm3 <- predict(fm3, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm3$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit - 1.96 * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + 1.96 * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
source('~/Teaching/bma590/bma590-fall21/r/class20.R', echo=TRUE)
fm1 <- nlme::gls(yield ~ variety, data = Wheat2)
require(plotly)
plot_ly(x = Wheat2$latitude,
y = Wheat2$longitude,
z = resid(fm1),
type = "scatter3d",
mode = "markers",
color = resid(fm1))
plot(Variogram(fm1, form = ~ latitude + longitude))
## spherical covariance
fm2 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corSpher(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
plot(Variogram(fm2, form = ~ latitude + longitude))
## Gaussian covariance
fm3 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corGaus(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
plot(Variogram(fm3, form = ~ latitude + longitude))
## linear covariance
fm4 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corLin(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
plot(Variogram(fm4, form = ~ latitude + longitude))
anova(fm1, fm2, fm3, fm4)
anova(fm1)
anova(fm4)
print(fm4)
anova(fm1, fm2, fm3, fm4)
print(fm4)
elephant <- read.table("data/elephant.txt", head = T)
head(elephant)
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
getwd()
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
fm2 <- glm(matings ~ age, family = poisson(link = "identity"), data = elephant)
summary(fm2)
predict.fm2 <- predict(fm2, newdata = new.data, type = "response", se.fit = TRUE)
new.data <- data.frame(age = seq(from = min(elephant$age),
to   = max(elephant$age),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm1$fit, col = "red")
# add lines for standard errors
lines(x   = new.data$age,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
fm2 <- glm(matings ~ age, family = poisson(link = "identity"), data = elephant)
summary(fm2)
predict.fm2 <- predict(fm2, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm2$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit - 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
par(mfrow = c(1, 2))
# deviance residuals
plot(x = elephant$age,
y = residuals(fm2, type = "deviance"),
xlab = "age",
ylab = "Deviance residuals")
abline(h = 0, lty = "dashed")
# compare with Pearson residuals
plot(x = elephant$age,
y = residuals(fm2, type = "pearson"),
xlab = "age",
ylab = "Pearson residuals")
abline(h = 0, lty = "dashed")
fm3 <- glm(matings ~ age, family = quasipoisson(link = "identity"), data = elephant)
summary(fm3)
predict.fm3 <- predict(fm3, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm3$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit + qt(0.025, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + qt(0.975, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
fm0 <- lm(matings ~ age, data = elephant)
fm1 <- glm(matings ~ age, family = gaussian, data = elephant)
summary(fm0)
summary(fm1)
sum(resid(fm0)^2)
fm2 <- lm(matings ~ 1, data =elephant)
sum(resid(fm2)^2)
residuals(fm1, type = "deviance")
resid(fm0)
fm2 <- glm(matings ~ age, family = poisson(link = "identity"), data = elephant)
predict(fm2)
head(elephant)
dpois(0, lambda = 0.8963, log = T)
residuals(fm2, type = "deviance")
sqrt(2 * 0.8963)
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
