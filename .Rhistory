curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.2, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71472 - 0.00938 * d)
dark.fit <- function(d) inv.logit(-0.71472 - 0.41024 + (-0.00938 + 0.02776) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.2, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph = "dark"), points(removed / placed ~ distance, pch = 16))
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71472 - 0.00938 * d)
dark.fit <- function(d) inv.logit(-0.71472 - 0.41024 + (-0.00938 + 0.02776) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.2, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71472 - 0.00938 * d)
dark.fit <- function(d) inv.logit(-0.71472 - 0.41024 + (-0.00938 + 0.02776) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.15, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
dark.fit(20)
require(lme4)
fm3 <- glmer(cbind(removed, placed - removed) ~ distance * morph + (1 | location),
family = binomial(link = "logit"),
data = moth)
summary(fm3)
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71979 - 0.00934 * d)
dark.fit <- function(d) inv.logit(-0.71979 - 0.41113 + (-0.00934 + 0.02782) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.15, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
dark.fit.glmm <- function(d) inv.logit(-0.71979 - 0.41113 + (-0.00934 + 0.02782) * d)
dark.fit.glmm(20)
ttt <- rnorm(1e5, sd = 0.1072)
mean(exp(ttt))
0.3192197/0.3183597
require(VGAM)
data(corbet)
head(corbet)
with(corbet, barplot(species, names = ofreq,
xlab = "no. of individuals",
ylab = "frequency"))
?VGAM::vglm
corbet.fit <- vglm(ofreq ~ 1, family = posnegbinomial, weights = species, data = corbet)
Coef(corbet.fit)
mu.hat <- Coef(corbet.fit)["munb"]
with(corbet, sum(ofreq*species) / sum(species))
mu.hat <- Coef(corbet.fit)["munb"]
k.hat  <- Coef(corbet.fit)["size"]
fitted.probs <- dgaitnbinom(x = corbet$ofreq, k.hat, munb.p = fitted(corbet.fit), truncate = 0)
fitted.vals <- sum(corbet$species) * fitted.probs
barplot(cbind(corbet$species, fitted.vals), beside = T, names = c("actual", "fitted"))
cod <- read.table("data/ParasiteCod.txt", head = T)
# remove observations with missing data
cod <- na.omit(cod)
summary(cod)
par(mfrow = c(3, 4), mar = c(2, 2, 1, 1), oma = c(3, 7, 0, 0), las = 1)
cod <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/ParasiteCod.txt", head = T)
# remove observations with missing data
cod <- na.omit(cod)
summary(cod)
par(mfrow = c(3, 4), mar = c(2, 2, 1, 1), oma = c(3, 7, 0, 0), las = 1)
for (i in unique(cod$Year)) {
for (j in sort(unique(cod$Area))) {
with(subset(cod, Year == i & Area == j),
plot(log(Intensity + 1) ~ Length, xlim = range(cod$Length), ylim = log(range(cod$Intensity) + 1),
xlab = "", ylab = "", yaxt = "n"))
axis(2, at = log(c(0, 10, 100) + 1), lab = c(0, 10, 100))
if (j == 1) mtext(i, side = 2, line  = 3)
}
}
mtext("length", side = 1, outer = T, line = 2)
mtext("parasite intensity", side = 2, outer = T, line = 5, las = 0)
require(pscl)
formula.1 <- formula(Intensity ~ Length + as.factor(Year) * as.factor(Area))
cod.nb.fm1 <- zeroinfl(formula.1, data  = cod, dist = "negbin")
summary(cod.nb.fm1)
with(cod, table(Year, Area, Intensity > 0))
formula.2 <- formula(Intensity ~ Length + as.factor(Year) * as.factor(Area) | Length
+ as.factor(Year) + as.factor(Area))
cod.nb.fm2 <- zeroinfl(formula.2, data  = cod, dist = "negbin")
summary(cod.nb.fm2)
length.vals <- seq(from = min(cod$Length), to = max(cod$Length), length = 100)
par(mfrow = c(3, 4), mar = c(2, 2, 1, 1), oma = c(3, 7, 0, 0), las = 1)
for (i in unique(cod$Year)) {
for (j in sort(unique(cod$Area))) {
new.data <- data.frame(Length = length.vals, Year = i, Area = j)
predicted.vals <- predict(cod.nb.fm2, newdata = new.data, type = "response")
plot(x = range(cod$Length), y = log(range(cod$Intensity) + 1), xlab = "", ylab = "", type = "n", yaxt = "n")
lines(log(predicted.vals + 1) ~ length.vals)
with(subset(cod, Year == i & Area == j), points(log(Intensity + 1) ~ Length))
axis(2, at = log(c(0, 10, 100) + 1), lab = c(0, 10, 100))
if (j == 1) mtext(i, side = 2, line  = 3)
}
}
mtext("length", side = 1, outer = T, line = 2)
mtext("parasite intensity", side = 2, outer = T, line = 6, las = 0)
formula.3 <- formula(Intensity ~ Length + as.factor(Year) + as.factor(Area) | as.factor(Year) * as.factor(Area))
cod.hurdle.fm3 <- hurdle(formula.3, data = cod, dist = "negbin")
summary(cod.hurdle.fm3)
rm(list = ls())
require(mgcv)
coral <- read.csv("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/coral.csv", head = TRUE, stringsAsFactors = TRUE)
head(coral)
with(coral, plot(jitter(mortality, amount = 0.02) ~ ln_area, xlab = "log area", ylab = "mortality"))
fm1 <- gam(mortality ~ s(ln_area), family = binomial(link = "logit"), data = coral)
with(coral, plot(jitter(mortality, amount = 0.02) ~ ln_area, xlab = "log area", ylab = "mortality"))
fm1 <- gam(mortality ~ s(ln_area), family = binomial(link = "logit"), data = coral)
summary(fm1)
with(coral, plot(jitter(mortality, amount = 0.02) ~ ln_area, xlab = "log area", ylab = "mortality"))
x.vals <- with(coral, seq(from = min(ln_area), to = max(ln_area), length = 100))
fm1.fit <- predict(fm1, newdata = data.frame(ln_area = x.vals), se = TRUE)
inv.logit <- function(x) exp(x) / (1 + exp(x))
lines(x.vals, inv.logit(fm1.fit$fit))
lines(x.vals, inv.logit(fm1.fit$fit + 1.96 * fm1.fit$se.fit), lty = "dashed")
lines(x.vals, inv.logit(fm1.fit$fit - 1.96 * fm1.fit$se.fit), lty = "dashed")
fm2 <- gam(mortality ~ s(ln_area), family = binomial(link = "cloglog"), data = coral)
with(coral, plot(jitter(mortality, amount = 0.02) ~ ln_area, xlab = "log area", ylab = "mortality"))
fm2.fit <- predict(fm2, newdata = data.frame(ln_area = x.vals), se = TRUE)
lines(x.vals, inv.logit(fm2.fit$fit), col = "red")
lines(x.vals, inv.logit(fm2.fit$fit + 1.96 * fm2.fit$se.fit), col = "red", lty = "dashed")
lines(x.vals, inv.logit(fm2.fit$fit - 1.96 * fm2.fit$se.fit), col = "red", lty = "dashed")
AIC(fm1, fm2)
require(pscl)
?predict.zeroinfl
formula.2 <- formula(Intensity ~ Length + as.factor(Year) * as.factor(Area) |
Length + as.factor(Year) + as.factor(Area))
cod.nb.fm2 <- zeroinfl(formula.2, data  = cod, dist = "negbin")
cod <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/ParasiteCod.txt", head = T)
# remove observations with missing data
cod <- na.omit(cod)
require(pscl)
formula.2 <- formula(Intensity ~ Length + as.factor(Year) * as.factor(Area) |
Length + as.factor(Year) + as.factor(Area))
cod.nb.fm2 <- zeroinfl(formula.2, data  = cod, dist = "negbin")
my.response <- predict(cod.nb.fm2, type = "response")
head(my.response)
head(cod)
my.response <- predict(cod.nb.fm2, type = "prob")
my.response <- predict(cod.nb.fm2, type = "response")
my.prob <- predict(cod.nb.fm2, type = "prob")
head(my.prob)
my.count <- predict(cod.nb.fm2, type = "count")
my.zero <- predict(cod.nb.fm2, type = "zero")
(1 - my.zero[1]) * my.count[1] - my.response[1]
length.vals <- seq(from = min(cod$Length), to = max(cod$Length), length = 100)
par(mfrow = c(3, 4), mar = c(2, 2, 1, 1), oma = c(3, 7, 0, 0), las = 1)
for (i in unique(cod$Year)) {
for (j in sort(unique(cod$Area))) {
new.data <- data.frame(Length = length.vals, Year = i, Area = j)
zinf.vals <- predict(cod.nb.fm2, newdata = new.data, type = "zero")
plot(x = range(cod$Length), y = c(0, 1), xlab = "", ylab = "", type = "n")
lines(zinf.vals ~ length.vals)
with(subset(cod, Year == i & Area == j), points(I(1 - Prevalence) ~ Length))
#axis(2, at = log(c(0, 10, 100) + 1), lab = c(0, 10, 100))
if (j == 1) mtext(i, side = 2, line  = 3)
}
}
for (i in unique(cod$Year)) {
for (j in sort(unique(cod$Area))) {
new.data <- data.frame(Length = length.vals, Year = i, Area = j)
zinf.vals <- predict(cod.nb.fm2, newdata = new.data, type = "zero")
plot(x = range(cod$Length), y = c(0, 1), xlab = "", ylab = "", type = "n")
lines(zinf.vals ~ length.vals)
#with(subset(cod, Year == i & Area == j), points(I(1 - Prevalence) ~ Length))
#axis(2, at = log(c(0, 10, 100) + 1), lab = c(0, 10, 100))
if (j == 1) mtext(i, side = 2, line  = 3)
}
}
mtext("length", side = 1, outer = T, line = 2)
mtext("prob. of zero inflation", side = 2, outer = T, line = 6, las = 0)
rdu <- read.table("data/rdu-temperature.txt", head = T)
# remove NA's, coded as -99
with(rdu, table(temp == -99))
rdu <- subset(rdu, temp > -99)
with(rdu, plot(temp ~ time, type = "l", xlab = "day"))
require(mgcv)
fm1 <- gamm(temp ~ s(doy, bs = "cc", k = 20) + s(time), data = rdu, correlation = corAR1(form = ~ 1 | yr))
summary(fm1$lme)
summary(fm1$lme)
summary(fm1$gam)
plot(fm1$gam)
getws()
getwd()
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("index.Rmd")
moth2 <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
elogit <- function(x) log(x / (1 - x))
moth2$elogit.diff <- with(moth2, elogit(d.removed / d.placed) - elogit(l.removed / l.placed))
fm1 <- lm(elogit.diff ~ distance, data = moth2)
with(moth2, plot(elogit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
confint(fm1)
require(geepack)
moth <- read.table("data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
contrasts(moth$morph) <- contr.treatment(n = 2, base = 2)
fm2 <- geeglm(cbind(removed, placed - removed) ~ distance * morph,
family = binomial(link = "logit"),
data   = moth,
id     = location,
corstr = "exchangeable")
summary(fm2)
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71472 - 0.00938 * d)
dark.fit <- function(d) inv.logit(-0.71472 - 0.41024 + (-0.00938 + 0.02776) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.15, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
dark.fit(20)
rm(list = ls())
moth2 <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
elogit <- function(x) log(x / (1 - x))
moth2$elogit.diff <- with(moth2, elogit(d.removed / d.placed) - elogit(l.removed / l.placed))
fm1 <- lm(elogit.diff ~ distance, data = moth2)
with(moth2, plot(elogit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
confint(fm1)
require(geepack)
moth <- read.table("data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
contrasts(moth$morph) <- contr.treatment(n = 2, base = 2)
fm2 <- geeglm(cbind(removed, placed - removed) ~ distance * morph,
family = binomial(link = "logit"),
data   = moth,
id     = location,
corstr = "exchangeable")
summary(fm2)
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71472 - 0.00938 * d)
dark.fit <- function(d) inv.logit(-0.71472 - 0.41024 + (-0.00938 + 0.02776) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.15, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
options(digits = 7)
dark.fit(20)
require(lme4)
fm3 <- glmer(cbind(removed, placed - removed) ~ distance * morph + (1 | location),
family = binomial(link = "logit"),
data = moth)
summary(fm3)
confint(fm3, parm = c("distance:morph1"))
dark.linpred.glmm <- function(d) -0.71979 - 0.41113 + (-0.00934 + 0.02782) * d
dark.fit.glmm <- function(d) inv.logit(dark.linpred.glmm(d))
dark.fit.glmm(20)
linpred.sample <- rnorm(1e6, mean = dark.linpred.glmm(20), sd = 0.1072)
prob.sample <- inv.logit(linpred.sample)
(conditional.mean <- inv.logit(dark.linpred.glmm(20)))
(marginal.mean <- mean(prob.sample))
par(mfrow = c(1, 2))
hist(linpred.sample, breaks = 50, xlab = "linear predictor", main = "")
hist(prob.sample, breaks = 50, xlab = "removal probability", main = "")
abline(v = conditional.mean, col = "darkorange", lwd =2)
abline(v = marginal.mean, col = "blue", lwd = 2)
linpred.sample <- rnorm(1e6, mean = dark.linpred.glmm(20), sd = 10 * 0.1072)
prob.sample <- inv.logit(linpred.sample)
(conditional.mean <- inv.logit(dark.linpred.glmm(20)))
(marginal.mean <- mean(prob.sample))
par(mfrow = c(1, 2))
hist(linpred.sample, breaks = 50, xlab = "linear predictor", main = "")
hist(prob.sample, breaks = 50, xlab = "removal probability", main = "")
abline(v = conditional.mean, col = "darkorange", lwd =2)
abline(v = marginal.mean, col = "blue", lwd = 2)
require(R2jags)
moth.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j]   ~ dbin(p[j], n[j])      # data distribution
p[j]   <- ilogit(eta[j])      # inverse link
eta[j] <- a[morph[j]] + b[morph[j]] * dist[j] + L[loc[j]]  # linear predictor,
}
for (j in 1:7){  # random effects for location
L[j] ~ dnorm(0, tau_L)
}
a[1] ~ dnorm (0.0, 1E-6)       # priors for intercept
a[2] ~ dnorm (0.0, 1E-6)       # priors for intercept
b[1] ~ dnorm (0.0, 1E-6)       # prior for slope
b[2] ~ dnorm (0.0, 1E-6)       # prior for slope
tau_L   ~ dgamma (0.01, 0.01)    # prior for location-level random effect
sd_L   <- pow(tau_L, -1/2)
b.diff <- b[1] - b[2]
}
jags.data <- list(y     = moth$removed,
n     = moth$placed,
dist  = moth$distance,
loc   = as.numeric(moth$location),
morph = as.numeric(moth$morph),
J     = nrow(moth))
jags.params <- c("a[1]", "a[2]", "b[1]", "b[2]", "b.diff", "sd_L")
jags.inits <- function(){
list("tau_L" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = moth.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
print(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
(post.mean   <- apply(mcmc.output, 2, mean))
HPDinterval(as.mcmc(mcmc.output['b.diff']))
bayesplot::mcmc_areas(mcmc.output,
pars = c("b.diff"),
prob = 0.95)
table(mcmc.output$b.diff > 0)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.2'] + post.mean['b.2'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = light$distance, y = light$prop.removed, pch = 16)
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.1'] + post.mean['b.1'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = dark$distance, y = dark$prop.removed, pch = 16)
#----------------------------
#
# ticks on red grouse
#
#-----------------------
rm(list = ls())
tick <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/tick.txt", head = T)
names(tick) <- c("index", "ticks", "brood", "elevation", "yr", "loc")
tick$index <- as.factor(tick$index)
tick$brood <- as.factor(tick$brood)
tick$yr    <- as.factor(tick$yr)
tick$loc   <- as.factor(tick$loc)
tick$elev.z <- with(tick, (elevation - mean(elevation)) / sd(elevation))
fm1  <- glmer(ticks ~ yr + elev.z + (1 | loc) + (1 | brood) + (1 | index),
family = "poisson",
data = tick)
summary(fm1)
pp <- profile(fm1)
confint(pp)
boar <- read.table("data/boar.txt", head = T)
# remove incomplete records
boar <- na.omit(boar)
# convert sex to a factor
boar$SEX <- as.factor(boar$SEX)
names(boar) <- c("tb", "sex", "age", "length")
summary(boar)
fm1 <- glm(tb ~ length, family = binomial(link = "logit"), data = boar)
summary(fm1)
coef(fm1)
coef(fm1)['length']
exp(coef(fm1)['length'])
getwd()
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
knitr::opts_chunk$set(echo = TRUE)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm0 <- lm(Yield ~ 1, data = Dyestuff)          # model with common mean
fm1 <- lm(Yield ~ Batch - 1, data = Dyestuff)  # mean varies by group
anova(fm0, fm1)  # usual F-test for differences among group means
summary(fm1)  # eliminating the intercept gives sample means for each group
require(nlme)
fm2 <- gls(Yield ~ 1, data = Dyestuff, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm2)
fm3 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm3)
(batch.conditional.modes <- (fixef(fm3) + ranef(fm3)$Batch$`(Intercept)`))
var(batch.conditional.modes)
1380/1764
5/6
x <- rep(1:n.site, rep(n, n.site))
source("~/.active-rstudio-document")
x
source("~/.active-rstudio-document")
plot(y~x)
site.effects
site <- rep(LETTERS[1:5], rep(n, n.site))
site <- as.factor(rep(LETTERS[1:5], rep(n, n.site)))
fm1 <- lmer(y ~ x + (1 | site))
summary(fm1)
sqrt(0.6269)
ranef(fm1)
var(ranef(fm1))
var(ranef(fm1)$site)
var(1:3)
?var
fm1.ml <- lmer(y ~ x + (1 | site), REML = FALSE)
summary(fm1.ml)
summary(fm1)
ranef(fm1)$site
var(ranef(fm1)$site)
View(fm1.ml)
fitted(fm1)
1.24-0.5174
1.24-0.5174-0.163
resid(fm1)
y[1]
plot(resid(fm1) ~ fitted(fm1))
abline(h = 0, lty = "dotted")
fm0 <- lm(y ~ x)
plot(resid(fm0) ~ fitted(fm0))
source("~/People/Old People/Kilpatrick/marm.R")
source("~/People/Old People/Kilpatrick/marm.R")
