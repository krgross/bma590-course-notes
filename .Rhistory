par    = c(a.w = 1, b.w = 1, a.n = 1, b.n = 1, k = 1)))
a.w.mle <- fir.full$par[1]
b.w.mle <- fir.full$par[2]
a.n.mle <- fir.full$par[3]
b.n.mle <- fir.full$par[4]
par(mfrow = c(1, 2))
# wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.w.mle * dbh.vals[i] ^ b.w.mle
}
dbh.vals <- seq(from = min(fir$dbh), to = max(fir$dbh), length = 100)
fit.vals <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.mle * dbh.vals[i] ^ b.mle
}
par(mfrow = c(1, 1))  # don't break the next figure into two panels
with(fir, plot(cones ~ dbh))  # plot the data points
lines(fit.vals ~ dbh.vals, col = "blue")
a.w.mle <- fir.full$par[1]
b.w.mle <- fir.full$par[2]
a.n.mle <- fir.full$par[3]
b.n.mle <- fir.full$par[4]
par(mfrow = c(1, 2))
# wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.w.mle * dbh.vals[i] ^ b.w.mle
}
lines(fit.vals ~ dbh.vals, col = "blue")
# non-wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.n.mle * dbh.vals[i] ^ b.n.mle
}
lines(fit.vals ~ dbh.vals, col = "red")
(lrt.stat <- 2 * (fir.reduced$value - fir.full$value))  # compute the likelihood ratio test statistic
(lrt.pvalue <- pchisq(q = lrt.stat, df = 2, lower.tail = FALSE))  # calculate the p-vlaue
(aic.reduced <- 2 * fir.reduced$value + 2 * 3)
(aic.full    <- 2 * fir.full$value    + 2 * 5)
(delta.aic   <- aic.full - aic.reduced)
a.w.mle <- fir.full$par[1]
b.w.mle <- fir.full$par[2]
a.n.mle <- fir.full$par[3]
b.n.mle <- fir.full$par[4]
par(mfrow = c(1, 2))
# wave populations
fit.vals.wave <- fit.vals.non <- double(length = length(dbh.vals))
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
for (i in seq(along = dbh.vals)) {
fit.vals.wave[i] <- a.w.mle * dbh.vals[i] ^ b.w.mle
}
lines(fit.vals.wave ~ dbh.vals, col = "blue")
# non-wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
for (i in seq(along = dbh.vals)) {
fit.vals.non[i] <- a.n.mle * dbh.vals[i] ^ b.n.mle
}
lines(fit.vals.non ~ dbh.vals, col = "red")
fir.neg.ll.pois <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
my.mu <- a * x^b
ll.values <- dpois(y, lambda = my.mu, log = TRUE)
-1 * sum(ll.values)
}
fir.reduced.pois <- optim(f   = fir.neg.ll.pois,
par = c(a = 1, b = 1),
x = fir$dbh,
y = fir$cones)
(a.mle.pois <- fir.reduced.pois$par[1])
(b.mle.pois <- fir.reduced.pois$par[2])
# calculate AIC
(aic.reduced.pois <- 2 * fir.reduced.pois$value + 2 * 2)
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fecundity.vals.pois ~ dbh.vals, col = "red")
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fit.vals.pois ~ dbh.vals, col = "red")
legend(x = 4, y = 280,
leg = c("Neg Bin", "Poisson"),
col = c("blue", "red"),
pch = 16,
bty = "n")
fir.neg.ll.pois <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
my.mu <- a * x^b
ll.values <- dpois(y, lambda = my.mu, log = TRUE)
-1 * sum(ll.values)
}
fir.pois <- optim(f   = fir.neg.ll.pois,
par = c(a = 1, b = 1),
x   = fir$dbh,
y   = fir$cones)
(a.mle.pois <- fir.pois$par[1])
(b.mle.pois <- fir.pois$par[2])
# calculate AIC
(aic.reduced.pois <- 2 * fir.reduced.pois$value + 2 * 2)
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fit.vals.pois ~ dbh.vals, col = "red")
legend(x = 4, y = 280,
leg = c("Neg Bin", "Poisson"),
col = c("blue", "red"),
pch = 16,
bty = "n")
# fit reduced model
fir.reduced <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones)
(a.mle <- fir.reduced$par[1])
(b.mle <- fir.reduced$par[2])
(k.mle <- fir.reduced$par[3])
dbh.vals <- seq(from = min(fir$dbh), to = max(fir$dbh), length = 100)
fit.vals <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.mle * dbh.vals[i] ^ b.mle
}
par(mfrow = c(1, 1))  # don't break the next figure into two panels
with(fir, plot(cones ~ dbh))  # plot the data points
lines(fit.vals ~ dbh.vals, col = "blue")
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fit.vals.pois ~ dbh.vals, col = "red")
legend(x = 4, y = 280,
leg = c("Neg Bin", "Poisson"),
col = c("blue", "red"),
pch = 16,
bty = "n")
?optim
fit.vals.alt <- double(length = length(dbh.vals))
?round
600/13
fish.mercury <- read.csv("~/Teaching/data/fish-mercury.txt", sep="", stringsAsFactors=TRUE)
View(fish.mercury)
fish <- fish.mercury
rm(fish.mercury)
fm1 <- lm(hg ~ age + site, data = fish)
summary(fm1)
contrasts(fm1)
contrasts(fish$site)
anova(fm1)
fm2 <- lm(log(hg) ~ age + site, data = fish)
anova(fm2)
7.276^2
with(fish, summary(fm(log(hg) ~ age)))
with(fish, summary(lm(log(hg) ~ age)))
horse <- read.table("data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
l.vals <- seq(from = 0, to = 2, length = 200)
plot(l.vals, dgamma(l.vals, shape = 196.01, rate = 280.01), type = "l",
xlab = expression(lambda), ylab = "")
lines(l.vals, dgamma(l.vals, shape = .01, rate = .01), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
getwd()
require(rstan)
options(mc.cores = parallel::detectCores())
horse.dat <- list(N = nrow(horse),
y = horse$deaths)
stan.fit <- stan(file = 'stan/horse.stan', data = horse.dat)
print(stan.fit)
plot(stan.fit)
196.01/380
horse.dat <- list(N = nrow(horse),
y = horse$deaths)
stan.fit <- stan(file = 'stan/horse.stan', data = horse.dat)
print(stan.fit)
cricket <- read.table("data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
```{r cache = TRUE}
cricket.dat <- list(N = nrow(cricket),
y = cricket$chirps,
x = cricket$temperature)
stan.fit <- stan(file = 'stan/cricket.stan', data = cricket.dat)
```
stan.fit <- stan(file = 'stan/cricket.stan', data = cricket.dat)
print(stan.fit)
stan.fit <- stan(file = 'stan/cricket.stan', data = cricket.dat)
print(stan.fit)
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
cricket.dat <- list(N = nrow(cricket),
y = cricket$chirps,
x = cricket$temp.ctr)
stan.fit <- stan(file = 'stan/cricket.stan', data = cricket.dat)
print(stan.fit)
?dgamma
pgamma(2/3, shape = 196.01, rate = 280.01, lower.tail = FALSE)
traceplot(jagsfit)
require(R2jags)
R2jags::traceplot(jagsfit)
coda::traceplot(jagsfit)
horse.model <- function() {
for (j in 1:J) {             # J = 280, number of data points
y[j] ~ dpois (lambda)      # data model:  the likelihood
}
lambda ~ dgamma (0.01, 0.01) # prior
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
}
jags.data <- list(y = horse$deaths, J = length(horse$deaths))
horse <- read.table("data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
l.vals <- seq(from = 0, to = 2, length = 200)
plot(l.vals, dgamma(l.vals, shape = 196.01, rate = 280.01), type = "l",
xlab = expression(lambda), ylab = "")
lines(l.vals, dgamma(l.vals, shape = .01, rate = .01), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
require(R2jags)
horse.model <- function() {
for (j in 1:J) {             # J = 280, number of data points
y[j] ~ dpois (lambda)      # data model:  the likelihood
}
lambda ~ dgamma (0.01, 0.01) # prior
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
}
jags.data <- list(y = horse$deaths, J = length(horse$deaths))
jags.params <- c("lambda")
jags.inits <- function(){
list("lambda" = rgamma(0.01, 0.01))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = horse.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
traceplot(jagsfit)
horse <- read.table("data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
l.vals <- seq(from = 0, to = 2, length = 200)
plot(l.vals, dgamma(l.vals, shape = 196.01, rate = 280.01), type = "l",
xlab = expression(lambda), ylab = "")
lines(l.vals, dgamma(l.vals, shape = .01, rate = .01), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
All that said, here is how you might use `rstanarm` most simply to fit the two working examples in this chapter.  We'll begin by fitting the horse-kick data:
```{r}
require(rstanarm)
```
```{r}
stanarm.horse.fit <- stan_glm(deaths ~ 1, data = horse, family = "poisson")
```
print(stanarm.horse.fit, digits = 3)
exp(-0.358)
stanarm.horse.fit <- stan_glm(deaths ~ 1, data = horse, family = poisson)
print(stanarm.horse.fit, digits = 3)
stanarm.horse.fit <- stan_glm(deaths ~ 1, data = horse, family = poisson, seed = 1)
print(stanarm.horse.fit, digits = 3)
stanarm.horse.fit <- stan_glm(deaths ~ 1, data = horse, family = poisson, seed = 1)
print(stanarm.horse.fit, digits = 3)
horse <- read.table("data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
l.vals <- seq(from = 0, to = 2, length = 200)
plot(l.vals, dgamma(l.vals, shape = 196.01, rate = 280.01), type = "l",
xlab = expression(lambda), ylab = "")
lines(l.vals, dgamma(l.vals, shape = .01, rate = .01), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
require(rstanarm)
stanarm.horse.fit <- stan_glm(deaths ~ 1, data = horse, family = poisson, seed = 1)
print(stanarm.horse.fit, digits = 3)
mcmc.sims <- as.matrix(stanarm.horse.fit)
summary(mcmc.sims)
cricket <- read.table("data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
require(rstanarm)
stanarm.cricket.fit <- stan_glm(chirps ~ temp.ctr, data = cricket, family = gaussian, seed = 1)
print(stanarm.cricket.fit, digits = 3)
mcmc.sims <- as.matrix(stanarm.horse.fit)
mcmc.sims <- as.matrix(stanarm.cricket.fit)
summary(mcmc.sims)
apply(mcmc.sims, 2, sd)
jags.data <- list(y = cricket$chirps,
x = cricket$temp.ctr,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
require(R2jags)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the residaul errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
?traceplot
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
jags.data <- list(y = cricket$chirps,
x = cricket$temp.ctr,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the residaul errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
str(jagsfit)
?sample
?lines
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
plot(chirps ~ temperature, data = cricket)
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue"))
}
?points
plot(chirps ~ temperature, data = cricket, type = "n")
# we'll add the points later so that they lie on top of the lines,
# instead of the other way around
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue"))
}
with(cricket, points(chirps ~ temperature))
plot(chirps ~ temperature, data = cricket, type = "n")
# we'll add the points later so that they lie on top of the lines,
# instead of the other way around
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.5))
}
with(cricket, points(chirps ~ temperature))
plot(chirps ~ temperature, data = cricket, type = "n")
# we'll add the points later so that they lie on top of the lines,
# instead of the other way around
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.2))
}
with(cricket, points(chirps ~ temperature))
plot(chirps ~ temperature, data = cricket, type = "n")
# we'll add the points later so that they lie on top of the lines,
# instead of the other way around
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 02))
}
with(cricket, points(chirps ~ temperature))
plot(chirps ~ temperature, data = cricket, type = "n")
# we'll add the points later so that they lie on top of the lines,
# instead of the other way around
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.5))
}
with(cricket, points(chirps ~ temperature))
plot(chirps ~ temperature, data = cricket, type = "n")
# we'll add the points later so that they lie on top of the lines,
# instead of the other way around
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.25))
}
with(cricket, points(chirps ~ temperature))
chirps.at.85 <- with(mcmc.output, b0 + b1 * 85)
summary(chirps.at.85)
?quantile
chirps.at.85 <- with(mcmc.output, b0 + b1 * 85)
summary(chirps.at.85)
quantile(chirps.at.85, probs = c(.025, 0.975))
?densityplot.mcmc
chirps.at.85 <- with(mcmc.output, b0 + b1 * 85)
summary(chirps.at.85)
densityplot(chirps.at.85)
chirps.at.85 <- with(mcmc.output, b0 + b1 * 85)
summary(chirps.at.85)
plot(density(chirps.at.85))
quantile(chirps.at.85, probs = c(.025, 0.975))
?density
n.sims <- nrow(mcmc.output)
new.errors <- with(mcmc.output, rnorm(n.sims, mean = 0, sd = sigma))
new.chirps.85 <- with(mcmc.output, b0 + b1 * 85) + new.errors
plot(density(new.chirps.85))
summary(new.chirps.85)
quantile(avg.chirps.85, probs = c(.025, 0.975))
n.sims <- nrow(mcmc.output)
new.errors <- with(mcmc.output, rnorm(n.sims, mean = 0, sd = sigma))
new.chirps.85 <- with(mcmc.output, b0 + b1 * 85) + new.errors
plot(density(new.chirps.85))
summary(new.chirps.85)
quantile(new.chirps.85, probs = c(.025, 0.975))
?HPDinterval
?coda::HPDinterval
?coda
cricket <- read.table("data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
require(rstanarm)
stanarm.cricket.fit <- stan_glm(chirps ~ temp.ctr, data = cricket, family = gaussian, seed = 1)
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
stanarm.cricket.fit <- stan_glm(chirps ~ temp.ctr, data = cricket, family = gaussian, seed = 1)
print(stanarm.cricket.fit, digits = 3)
mcmc.sims <- as.matrix(stanarm.cricket.fit)
summary(mcmc.sims)
apply(mcmc.sims, 2, sd)
apply(mcmc.sims, 2, function(x) quantile(x, c(0.025, 0.975)))
