getwd()
horse <- read.table("data/horse.txt", header = TRUE)
horse <- read.table("/data/horse.txt", header = TRUE)
horse <- read.table("data/horse.txt", header = TRUE)
install.packages("bookdown")
file.create('.nojekyll').
file.create('.nojekyll')
horse <- read.table("data/horse.txt", header = TRUE)
str(horse)
?dpois
lambda.values <- seq(from = 0, to = 5, by = 0.01)
my.lhood <- dpois(x = 2, lambda = lambda.values)
plot(lambda.vals, my.lhood, xlab = expression(lambda), ylab = "Likelihood", type = "l")
lambda.vals <- seq(from = 0, to = 5, by = 0.01)
my.lhood <- dpois(x = 2, lambda = lambda.values)
plot(lambda.vals, my.lhood, xlab = expression(lambda), ylab = "Likelihood", type = "l")
plot(lambda.vals, my.lhood, xlab = expression(lambda), ylab = "Likelihood", type = "l")
abline(v = 2, col = "red")
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt", header = TRUE)
source('~/Teaching/bma590/bma590-fall21/r/class01.R')
install.packages("numDeriv", repos = "http://cran.rstudio.com")
install.packages("numDeriv", repos = "http://cran.rstudio.com")
?numDeriv
?numDeriv::hessian
library(emdbook)
data("ReedfrogFuncresp")
# rename something shorter
frog <- ReedfrogFuncresp
rm(ReedfrogFuncresp)
frog.neg.ll <- function(params){
a <- params[1]
h <- params[2]
prob.vals <- a / (1 + a * h * frog$Initial)
ll.vals <- dbinom(frog$Killed, size = frog$Initial, prob = prob.vals, log = TRUE)
-1 * sum(ll.vals)
}
frog.mle <- optim(par = c(0.5, 1/60),
fn  = frog.neg.ll)
(a.mle <- frog.mle$par[1])
(h.mle <- frog.mle$par[2])
(D2 <- numDeriv::hessian(func = frog.neg.ll, x = c(a.mle, h.mle)))
# invert to get var-cov matrix
(var.matrix <- solve(D2))
(a.se <- sqrt(var.matrix[1, 1]))
(h.se <- sqrt(var.matrix[2, 2]))
(lower.approx <- a.mle - qnorm(.975) * a.se)
(upper.approx <- a.mle + qnorm(.975) * a.se)
?cov2cor
cov2cor(var.matrix)
beer <- read.csv("~/Teaching/data/beer.txt", sep="")
View(beer)
fm1 <- with(beer, lm(BAC ~ Beers))
summary(fm1)
confint(fm1)
?search
search()
require(emdbook)
data("FirDBHFec")
# give the data a simpler name
fir <- FirDBHFec
rm(FirDBHFec)
fir <- fir[, c("WAVE_NON", "DBH", "TOTCONES")]  # select just the variables we want
summary(fir)
names(fir) <- c("wave", "dbh", "cones")  # rename the variables
par(mfrow = c(1, 2))
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
fir.neg.ll <- function(parms){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * fir$dbh^b
ll.values <- dnbinom(fir$cones, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
# fit reduced model
fir.reduced <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1))
fir.neg.ll(c(1, 1, 1))
require(emdbook)
data("FirDBHFec")
# give the data a simpler name
fir <- FirDBHFec
rm(FirDBHFec)
fir <- fir[, c("WAVE_NON", "DBH", "TOTCONES")]  # select just the variables we want
summary(fir)
names(fir) <- c("wave", "dbh", "cones")  # rename the variables
# get rid of the incomplete records
fir <- na.omit(fir)
par(mfrow = c(1, 2))
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
# any non-integral responses?
with(fir, table(cones == round(cones)))  # illustrate the use of 'with'
# round the non-integral values
fir$cones <- round(fir$cones)
# check
with(fir, table(cones == round(cones)))
fir.neg.ll <- function(parms){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * fir$dbh^b
ll.values <- dnbinom(fir$cones, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
# fit reduced model
fir.reduced <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1))
(a.mle <- fir.reduced$par[1])
(b.mle <- fir.reduced$par[2])
(k.mle <- fir.reduced$par[3])
dbh.vals <- seq(from = min(fir$dbh), to = max(fir$dbh), length = 100)
fecundity.vals <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fecundity.vals[i] <- a.mle * dbh.vals[i] ^ b.mle
}
par(mfrow = c(1, 1))  # don't break the next figure into two panels
with(fir, plot(cones ~ dbh))  # plot the data points
lines(fecundity.vals ~ dbh.vals, col = "blue")
?optim
fir.neg.ll <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * x^b
ll.values <- dnbinom(y, size = k, mu = my.mu, log = TRUE)
neg.ll <- -1 * sum(ll.values)
return(neg.ll)
}
# fit reduced model
fir.reduced <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones)
(a.mle <- fir.reduced$par[1])
(b.mle <- fir.reduced$par[2])
(k.mle <- fir.reduced$par[3])
fir.neg.ll.full <- function(parms) {
a.w <- parms[1]
b.w <- parms[2]
a.n <- parms[3]
b.n <- parms[4]
k   <- parms[5]
wave    <- subset(fir, wave == "w")
nonwave <- subset(fir, wave == "n")
# note how we call fir.neg.ll here, but each time only
# passing a subset of the data
neg.ll.wave     <- fir.neg.ll(parms = c(a = a.w, b = b.w, k = k),
x     = wave$dbh,
y     = wave$cones)
neg.ll.nonwave  <- fir.neg.ll(parms = c(a = a.n, b = b.n, k = k),
x     = nonwave$dbh,
y     = nonwave$cones)
total.ll <- neg.ll.wave + neg.ll.nonwave
return(total.ll)
}
fir.full <- optim(f      = fir.neg.ll.full,
par    = c(a.w = 1, b.w = 1, a.n = 1, b.n = 1, k = 1),
mydata = fir)
fir.neg.ll.full <- function(parms) {
a.w <- parms[1]
b.w <- parms[2]
a.n <- parms[3]
b.n <- parms[4]
k   <- parms[5]
wave    <- subset(fir, wave == "w")
nonwave <- subset(fir, wave == "n")
# note how we call fir.neg.ll here, but each time only
# passing a subset of the data
neg.ll.wave     <- fir.neg.ll(parms = c(a = a.w, b = b.w, k = k),
x     = wave$dbh,
y     = wave$cones)
neg.ll.nonwave  <- fir.neg.ll(parms = c(a = a.n, b = b.n, k = k),
x     = nonwave$dbh,
y     = nonwave$cones)
total.ll <- neg.ll.wave + neg.ll.nonwave
return(total.ll)
}
fir.full <- optim(f      = fir.neg.ll.full,
par    = c(a.w = 1, b.w = 1, a.n = 1, b.n = 1, k = 1))
fir.neg.ll.full <- function(parms) {
a.w <- parms[1]
b.w <- parms[2]
a.n <- parms[3]
b.n <- parms[4]
k   <- parms[5]
wave    <- subset(fir, wave == "w")
nonwave <- subset(fir, wave == "n")
# note how we call fir.neg.ll here, but each time only
# passing a subset of the data
neg.ll.wave     <- fir.neg.ll(parms = c(a = a.w, b = b.w, k = k),
x     = wave$dbh,
y     = wave$cones)
neg.ll.nonwave  <- fir.neg.ll(parms = c(a = a.n, b = b.n, k = k),
x     = nonwave$dbh,
y     = nonwave$cones)
total.ll <- neg.ll.wave + neg.ll.nonwave
return(total.ll)
}
(fir.full <- optim(f      = fir.neg.ll.full,
par    = c(a.w = 1, b.w = 1, a.n = 1, b.n = 1, k = 1)))
a.w.mle <- fir.full$par[1]
b.w.mle <- fir.full$par[2]
a.n.mle <- fir.full$par[3]
b.n.mle <- fir.full$par[4]
par(mfrow = c(1, 2))
# wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.w.mle * dbh.vals[i] ^ b.w.mle
}
dbh.vals <- seq(from = min(fir$dbh), to = max(fir$dbh), length = 100)
fit.vals <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.mle * dbh.vals[i] ^ b.mle
}
par(mfrow = c(1, 1))  # don't break the next figure into two panels
with(fir, plot(cones ~ dbh))  # plot the data points
lines(fit.vals ~ dbh.vals, col = "blue")
a.w.mle <- fir.full$par[1]
b.w.mle <- fir.full$par[2]
a.n.mle <- fir.full$par[3]
b.n.mle <- fir.full$par[4]
par(mfrow = c(1, 2))
# wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.w.mle * dbh.vals[i] ^ b.w.mle
}
lines(fit.vals ~ dbh.vals, col = "blue")
# non-wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.n.mle * dbh.vals[i] ^ b.n.mle
}
lines(fit.vals ~ dbh.vals, col = "red")
(lrt.stat <- 2 * (fir.reduced$value - fir.full$value))  # compute the likelihood ratio test statistic
(lrt.pvalue <- pchisq(q = lrt.stat, df = 2, lower.tail = FALSE))  # calculate the p-vlaue
(aic.reduced <- 2 * fir.reduced$value + 2 * 3)
(aic.full    <- 2 * fir.full$value    + 2 * 5)
(delta.aic   <- aic.full - aic.reduced)
a.w.mle <- fir.full$par[1]
b.w.mle <- fir.full$par[2]
a.n.mle <- fir.full$par[3]
b.n.mle <- fir.full$par[4]
par(mfrow = c(1, 2))
# wave populations
fit.vals.wave <- fit.vals.non <- double(length = length(dbh.vals))
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
for (i in seq(along = dbh.vals)) {
fit.vals.wave[i] <- a.w.mle * dbh.vals[i] ^ b.w.mle
}
lines(fit.vals.wave ~ dbh.vals, col = "blue")
# non-wave populations
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
for (i in seq(along = dbh.vals)) {
fit.vals.non[i] <- a.n.mle * dbh.vals[i] ^ b.n.mle
}
lines(fit.vals.non ~ dbh.vals, col = "red")
fir.neg.ll.pois <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
my.mu <- a * x^b
ll.values <- dpois(y, lambda = my.mu, log = TRUE)
-1 * sum(ll.values)
}
fir.reduced.pois <- optim(f   = fir.neg.ll.pois,
par = c(a = 1, b = 1),
x = fir$dbh,
y = fir$cones)
(a.mle.pois <- fir.reduced.pois$par[1])
(b.mle.pois <- fir.reduced.pois$par[2])
# calculate AIC
(aic.reduced.pois <- 2 * fir.reduced.pois$value + 2 * 2)
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fecundity.vals.pois ~ dbh.vals, col = "red")
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fit.vals.pois ~ dbh.vals, col = "red")
legend(x = 4, y = 280,
leg = c("Neg Bin", "Poisson"),
col = c("blue", "red"),
pch = 16,
bty = "n")
fir.neg.ll.pois <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
my.mu <- a * x^b
ll.values <- dpois(y, lambda = my.mu, log = TRUE)
-1 * sum(ll.values)
}
fir.pois <- optim(f   = fir.neg.ll.pois,
par = c(a = 1, b = 1),
x   = fir$dbh,
y   = fir$cones)
(a.mle.pois <- fir.pois$par[1])
(b.mle.pois <- fir.pois$par[2])
# calculate AIC
(aic.reduced.pois <- 2 * fir.reduced.pois$value + 2 * 2)
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fit.vals.pois ~ dbh.vals, col = "red")
legend(x = 4, y = 280,
leg = c("Neg Bin", "Poisson"),
col = c("blue", "red"),
pch = 16,
bty = "n")
# fit reduced model
fir.reduced <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones)
(a.mle <- fir.reduced$par[1])
(b.mle <- fir.reduced$par[2])
(k.mle <- fir.reduced$par[3])
dbh.vals <- seq(from = min(fir$dbh), to = max(fir$dbh), length = 100)
fit.vals <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.mle * dbh.vals[i] ^ b.mle
}
par(mfrow = c(1, 1))  # don't break the next figure into two panels
with(fir, plot(cones ~ dbh))  # plot the data points
lines(fit.vals ~ dbh.vals, col = "blue")
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")  # plot the fit from the NegBin model
## calculate and plot the fit for the Poisson model
fit.vals.pois <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.pois[i] <- a.mle.pois * dbh.vals[i] ^ b.mle.pois
}
lines(fit.vals.pois ~ dbh.vals, col = "red")
legend(x = 4, y = 280,
leg = c("Neg Bin", "Poisson"),
col = c("blue", "red"),
pch = 16,
bty = "n")
?optim
fit.vals.alt <- double(length = length(dbh.vals))
?round
600/13
fish.mercury <- read.csv("~/Teaching/data/fish-mercury.txt", sep="", stringsAsFactors=TRUE)
View(fish.mercury)
fish <- fish.mercury
rm(fish.mercury)
fm1 <- lm(hg ~ age + site, data = fish)
summary(fm1)
contrasts(fm1)
contrasts(fish$site)
anova(fm1)
fm2 <- lm(log(hg) ~ age + site, data = fish)
anova(fm2)
7.276^2
with(fish, summary(fm(log(hg) ~ age)))
with(fish, summary(lm(log(hg) ~ age)))
