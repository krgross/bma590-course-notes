col = "red", lty = "dotted")
}
abline(a = fixef(fm2a)[1], b = fixef(fm2a)[2], col = "red", lwd = 2)
abline(a = fixef(fm2a)[1], b = fixef(fm2a)[2], col = "red", lwd = 2)
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = high.beaches, pch = high.beaches)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
summary(fm3)
fm4 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 + NAP| fBeach), data = rikz)
summary(fm4)
fm5 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach) + (0 + NAP | fBeach),
data = rikz)
summary(fm5)
anova(fm3, fm4, fm5)
pr <- profile(fm3)
lattice::xyplot(pr, absVal = T)
confint(pr)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
summary(fm3)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
legend("topright", leg = high.beaches, pch = high.beaches)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm1 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm1)
ranef(fm1)
(batch.conditional.modes <- (fixef(fm1) + ranef(fm1)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
fm1.ML <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff, REML = FALSE)
summary(fm1.ML)
pr <- profile(fm1.ML)
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = 0.95)
confint(pr, level = 0.99)
fm2 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm2)
lattice::splom(pr)
lattice::dotplot(ranef(fm2, condVar = TRUE))
moth <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
moth
with(moth, plot(removed / placed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
logit <- function(x) log(x / (1 - x))
moth$logit_removed <- with(moth, logit(removed / placed))
with(moth, plot(logit_removed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(logit_removed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(logit_removed ~ distance, pch = 1))
mm1 <- lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
mm1 <- lmer(logit_removed ~ distance + morph + distance:morph + (1 | location), data = moth)
summary(mm1)
abline(a = -1.1233, b = 0.01819) # dark fit
abline(a = -1.1233 + 0.3738, b = 0.01819 - 0.02758, lty = "dashed")  # light fit
pr <- profile(mm1)  # remember this is the ML fit
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = .95)
mm1a <- lmerTest::lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
summary(mm1a)
moth2 <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
logit <- function(x) log(x / (1 - x))
moth2$logit.diff <- with(moth2, logit(d.removed / d.placed) - logit(l.removed / l.placed))
fm1 <- lm(logit.diff ~ distance, data = moth2)
with(moth2, plot(logit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
require(lme4)
require(R2jags)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
jags.data <- list(y     = Dyestuff$Yield,
batch = as.numeric(Dyestuff$Batch),
J     = nrow(Dyestuff))
jags.params <- c("mu", "sd_eps", "sdB", "B[1]", "B[2]")
jags.inits <- function(){
list("mu" = rnorm(1, .01), "tauB" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = dyestuff.model,
n.chains           = 3,
n.iter             = 1e5)
print(jagsfit)
traceplot(jagsfit)
dyestuff.model <- function() {
## likelihood
for (j in 1:J) {
y[j] ~ dnorm(B[batch[j]], tau_eps)  # data distribution
}
## latent variables
for (b in 1:6){
B[b] ~ dnorm(mu, tauB)
}
mu ~ dnorm (0.0, 1E-6)  # prior for the overall mean
tau_eps ~ dgamma (0.01, 0.01)
tauB    ~ dgamma (0.01, 0.01)
sd_eps <- pow(tau_eps, -1/2)
sdB    <- pow(tauB, -1/2)
}
jags.data <- list(y     = Dyestuff$Yield,
batch = as.numeric(Dyestuff$Batch),
J     = nrow(Dyestuff))
jags.params <- c("mu", "sd_eps", "sdB", "B[1]", "B[2]")
jags.inits <- function(){
list("mu" = rnorm(1, .01), "tauB" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = dyestuff.model,
n.chains           = 3,
n.iter             = 1e5)
print(jagsfit)
traceplot(jagsfit)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
data(Dyestuff2)
summary(Dyestuff2)
with(Dyestuff2, stripchart(Yield ~ Batch, pch = 16))
require(nlme)
fm6 <- lme4::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
summary(fm6)
fm5 <- gls(Yield ~ 1, data = Dyestuff2, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm5)
fm6 <- lme4::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
fm7 <- lme4::lmer(Yield ~ 1, data = Dyestuff2)
rm(list = ls())
ant <- read.csv("C:/Users/krgross/Documents/Teaching/bma590/general/data/ant.csv", head = T, stringsAsFactors = T)
ant_s <- droplevels(subset(ant, genus_species != "Brachyponera chinensis"))
summary(ant_s)
with(ant_s, table(tree_code, site))
with(ant_s, table(genus_species, stratum))
with(ant_s, table(genus_species, site))
with(ant_s, table(genus_species, tree_code))
fm1 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
summary(fm1)
fm2 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | genus_species),
data = ant_s)
summary(fm2)
pr <- profile(fm1)
lattice::xyplot(pr, absVal = T)
confint(pr)
fm1b <- lmerTest::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
summary(fm1b)
s_data <- with(ant_s, aggregate(ct_max, list(stratum, genus_species), FUN = mean))  # note the rows are sorted alphabetically by species
names(s_data) <- c("stratum", "species", "avg")
s_data$blup <- ranef(fm1)$genus_species[, 1] + coef(summary(fm1))[1, 1] + ifelse(s_data$stratum == "terrestrial", coef(summary(fm1))[2, 1], 0)
# with(s_data, stripchart(avg ~ stratum))
with(s_data, stripchart(blup ~ stratum, pch = 16))
with(s_data, plot(blup ~ avg, type = "n"))
with(subset(s_data, stratum == "arboreal"), points(blup ~ avg, pch = "A"))
with(subset(s_data, stratum != "arboreal"), points(blup ~ avg, pch = "T"))
abline(a = 0, b = 1)
head(ant)s
head(ant_s)
table(ant_s$nest)
subset(ant_s, nest == "AN1")
knitr::opts_chunk$set(echo = TRUE)
ant <- read.csv("data/ant.csv", head = T, stringsAsFactors = T)
ant_s <- droplevels(subset(ant, genus_species != "Brachyponera chinensis"))  # exclude the generalist
ant_s <- ant_s[, c(2, 3, 5, 6, 8)]  # remove irrelevant variables
names(ant_s) <- c("site", "tree", "habitat", "species", "ct_max")
summary(ant_s)
s_data <- with(ant_s, aggregate(ct_max, list(stratum, genus_species), FUN = mean))  # note the rows are sorted alphabetically by species
s_data <- with(ant_s, aggregate(ct_max, list(habitat, genus_species), FUN = mean))  # note the rows are sorted alphabetically by species
s_data <- with(ant_s, aggregate(ct_max, list(habitat, species), FUN = mean))  # note the rows are sorted alphabetically by species
names(s_data) <- c("habitat", "species", "avg")
with(s_data, stripchart(avg ~ habitat, pch = 16))
fm1 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
fm1 <- lme4::lmer(ct_max ~ habitat + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
fm1 <- lme4::lmer(ct_max ~ habitat + (1 | site) + (1 | site:tree) + (1 | species),
data = ant_s)
summary(fm1)
pr <- profile(fm1)
lattice::xyplot(pr, absVal = T)
confint(pr)
fm1b <- lmerTest::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
getwd
getwd()
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::preview_chapter("06-HierarchicalModels.Rmd", "bookdown::gitbook")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
knitr::opts_chunk$set(echo = TRUE)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
require(nlme)
fm1 <- gls(Yield ~ 1, data = Dyestuff, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm1)
fm2 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm2)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm2)
(batch.conditional.modes <- (fixef(fm2) + ranef(fm2)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
fm2ML <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff, REML = FALSE)
summary(fm2ML)
pr <- profile(fm2ML)
lattice::xyplot(pr)
confint(pr, level = .95)
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = 0.99)
lattice::splom(pr)
require(lmerTest)
fm3 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
1527.5 + 19.38 *  qt(c(0.025, 0.975), df = 5)
lattice::dotplot(ranef(fm2, condVar = TRUE))
require(R2jags)
dyestuff.model <- function() {
## likelihood
for (j in 1:J) {
y[j]    ~ dnorm(B[batch[j]], tau_eps)  # data distribution
}
## latent variables
for (b in 1:6){
B[b] ~ dnorm(mu, tauB)
}
mu ~ dnorm (0.0, 1E-6)  # prior for the overall mean
tau_eps ~ dgamma(.01, .01)  # ok here because these are precisions
tauB    ~ dgamma(.01, .01)
sd_eps <- pow(tau_eps, -1/2)
sdB    <- pow(tauB, -1/2)
}
jags.data <- list(y     = Dyestuff$Yield,
batch = as.numeric(Dyestuff$Batch),
J     = nrow(Dyestuff))
jags.params <- c("mu", "sd_eps", "sdB", "B[1]", "B[2]")
jags.inits <- function(){
list("mu" = rnorm(1, .01), "tauB" = dexp(1, 1), "tau_eps" = dexp(1, 1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = dyestuff.model,
n.chains           = 3,
n.iter             = 1e5,
jags.seed          = 1)
print(jagsfit)
traceplot(jagsfit)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
data(Dyestuff2)
summary(Dyestuff2)
with(Dyestuff2, stripchart(Yield ~ Batch, pch = 16))
fm6 <- gls(Yield ~ 1, data = Dyestuff2, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm6)
fm6 <- lme4::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
summary(fm6)
moth2 <- read.table("data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
elogit <- function(x) log(x / (1 - x))
moth2$elogit.diff <- with(moth2, elogit(d.removed / d.placed) - elogit(l.removed / l.placed))
fm1 <- lm(elogit.diff ~ distance, data = moth2)
with(moth2, plot(elogit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
confint(fm1)
moth <- read.table("data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
moth$logit_removed <- with(moth, elogit(removed / placed))
mm1 <- lme4::lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
summary(mm1)
with(moth, plot(logit_removed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(logit_removed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(logit_removed ~ distance, pch = 1))
abline(a = -1.1233, b = 0.01819) # dark fit
abline(a = -1.1233 + 0.3738, b = 0.01819 - 0.02758, lty = "dashed")  # light fit
mm1a <- lmerTest::lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
summary(mm1a)
ranef(mm1)
require(lme4)
require(lmerTest)
rikz <- read.table("data/RIKZ.txt", head = T)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
# change the Beach variable to a factor
# would have been better to code the beaches as b1, b2, ...
rikz$fBeach <- as.factor(rikz$Beach)
fm0 <- lm(sqrt(Richness) ~ fBeach + NAP, data = rikz)
summary(fm0)
confint(fm0, level = 0.95)
anova(fm0)
fm0.temp <- lm(sqrt(Richness) ~ fBeach + NAP - 1, data = rikz)
coef(fm0.temp)
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Fixed-effects fit, additive model"))
legend("topright", leg = 1:9, pch = 1:9)
# add a line for each beach
b <- coef(fm0)["NAP"]
for(i in 1:9){
abline(a = coef(fm0.temp)[i], b = b, col = "red", lty = "dotted")
}
rm(fm0.temp)
fm0b <- lm(sqrt(Richness) ~ fBeach * NAP, data = rikz)
summary(fm0b)
anova(fm0, fm0b)
fm0b.temp <- lm(sqrt(Richness) ~ fBeach + fBeach:NAP - 1, data = rikz)
(fixed.params <- data.frame(beach     = 1:9,
intercept = coef(fm0b.temp)[1:9],
slope     = coef(fm0b.temp)[10:18]))
row.names(fixed.params) <- NULL
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Fixed-effects fit, with beach-NAP interaction"))
legend("topright", leg = 1:9, pch = 1:9)
for(i in 1:9){
abline(a = fixed.params$intercept[i], b = fixed.params$slope[i],
col = "red", lty = "dotted")
}
rm(fm0b.temp)
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
(beach.conditional.modes <- (fixef(fm1)["(Intercept)"] + ranef(fm1)$fBeach$`(Intercept)`))
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Random intercepts fit"))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# make a plot with a line for each beach
for(i in 1:9){
abline(a = beach.conditional.modes[i], b = b, col = "red", lty = "dotted")
}
fm2 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 + NAP | fBeach), data = rikz)
summary(fm2)
anova(fm1, fm2)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach) + (0 + NAP | fBeach), data = rikz)
summary(fm3)
anova(fm1, fm3, fm2)
(conditional.modes  <- data.frame(beach     = 1:9,
intercept = fixef(fm3)["(Intercept)"] + ranef(fm3)$fBeach$`(Intercept)`,
slope     = fixef(fm3)["NAP"] + ranef(fm3)$fBeach$`NAP`))
par(mfrow = c(1, 2))
with(fixed.params, plot(slope ~ intercept, main = "fixed-effects fit", pch = 1:9))
with(fixed.params, plot(slope ~ intercept, main = "conditional modes", type = "n"))
with(conditional.modes, points(slope ~ intercept, pch = 1:9))
points(fixef(fm3)[1], fixef(fm3)[2], pch = 16, col = "red", cex = 2)
par(mfrow = c(1, 1))
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Random-coefficients fit"))
legend("topright", leg = 1:9, pch = 1:9)
for(i in 1:9){
abline(a = conditional.modes$intercept[i], b = conditional.modes$slope[i],
col = "red", lty = "dotted")
}
abline(a = fixef(fm3)[1], b = fixef(fm3)[2], col = "red", lwd = 2)
# create an 'exposure' factor, with two levels: low and high
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
fm4 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
summary(fm4)
fm5 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach) + (0 + NAP | fBeach),
data = rikz)
summary(fm5)
fm6 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 + NAP| fBeach), data = rikz)
summary(fm6)
anova(fm4, fm5, fm6)
summary(fm4)
a0 <- fixef(fm4)[1]  # mean intercept for low-exposure beaches
b0 <- fixef(fm4)[2]  # mean slope for low-exposure beaches
a1 <- fixef(fm4)[3]  # difference in mean intercepts for high vs low
b1 <- fixef(fm4)[4]  # difference in mean slopes for high vs low
c.mode <- ranef(fm4)$fBeach
low.beaches <- c(1, 2, 5, 8, 9) # indices of the low-exposure beaches
high.beaches <- c(3, 4, 6, 7) # indices of the high-exposure beacues
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
# Repeat for high exposure beaches
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
rm(list = ls())
library(MASS)
require(lme4)
require(lmerTest)
data(oats)
summary(oats)
fm1 <- lmerTest::lmer(Y ~ V * N + (1 | B) + (1 | B : V), data = oats)
# for nested random effects, lmer provides the coding shortcut
fm1a <- lmerTest::lmer(Y ~ V * N + (1 | B / V), data = oats)
summary(fm1)
anova(fm1)
contrasts(oats$N) <- contr.poly(n = 4)
fm1 <- lmerTest::lmer(Y ~ V * N +  (1 | B) + (1 | B : V), data = oats)
summary(fm1)
with(oats, plot(Y ~ N))
rm(list = ls())
golf <- read.table("data/golf.txt", head = T)
fm1 <- lmerTest::lmer(score ~ 1 + (1 | player) + (1 | round), data = golf)
summary(fm1)  # comparison of the std devs of the random effects is interesting
pp.golf <- profile(fm1)
confint(pp.golf)
lattice::xyplot(pp.golf, absVal = TRUE)
player.modes <- ranef(fm1)$player
head(player.modes)
(round.modes <- ranef(fm1)$round)
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes[, 1],
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", ylab = "rounds played",
xlab = "conditional mode", pch = 1))
knitr::include_graphics("images/sports-comic.png", dpi = 100)
rm(list = ls())
ant <- read.csv("data/ant.csv", head = T, stringsAsFactors = T)
ant_s <- droplevels(subset(ant, genus_species != "Brachyponera chinensis"))  # exclude the generalist
ant_s <- ant_s[, c(2, 3, 5, 6, 8)]  # remove irrelevant variables
names(ant_s) <- c("site", "tree", "habitat", "species", "ct_max")
summary(ant_s)
with(ant_s, table(species, site))
s_data <- with(ant_s, aggregate(ct_max, list(habitat, species), FUN = mean))  # note the rows are sorted alphabetically by species
names(s_data) <- c("habitat", "species", "avg")
with(s_data, stripchart(avg ~ habitat, pch = 16))
fm1 <- lme4::lmer(ct_max ~ habitat + (1 | site) + (1 | site:tree) + (1 | species),
data = ant_s)
summary(fm1)
s_data$blup <- ranef(fm1)$genus_species[, 1] + coef(summary(fm1))[1, 1] + ifelse(s_data$stratum == "terrestrial", coef(summary(fm1))[2, 1], 0)
s_data$blup <- ranef(fm1)$species[, 1] + coef(summary(fm1))[1, 1] + ifelse(s_data$habitat == "terrestrial", coef(summary(fm1))[2, 1], 0)
with(s_data, stripchart(blup ~ stratum, pch = 16))
s_data$blup <- ranef(fm1)$species[, 1] + coef(summary(fm1))[1, 1] + ifelse(s_data$habitat == "terrestrial", coef(summary(fm1))[2, 1], 0)
with(s_data, stripchart(blup ~ habitat, pch = 16))
bookdown::preview_chapter("06-HierarchicalModels.Rmd", "bookdown::gitbook")
bookdown::preview_chapter("06-HierarchicalModels.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
