my_load <- function(s)
q_hat <- MarginalAuthor_wDesk(k = k, v = v, z = z, sig_x = sig_x, sig_y = sig_y, sig_z = sig_z)
y_hat <- FindYForQ_wDesk(q_hat, z = z, v = v, sig_x = sig_x, sig_y = sig_y, sig_z = sig_z)
load <- ReviewLoad_wDesk(k = k, v = v, z = z, sig_x = sig_x, sig_y = sig_y, sig_z = sig_z)
journal_utility <- Avg_Accepted_Type_wDesk(x = AuthorX(q_hat, sig_x), y = y_hat, z = z, sig_x = sig_x, sig_y = sig_y, sig_z = sig_z)
ans <- c(q_hat, y_hat, load, journal_utility)
names(ans) <- c("q_hat", "y_hat", "load", "j_utility")
ans
}
ChangingVarEquilibrium_wDesk <- function(k = 0.2, v = 3, z = -Inf, sig_x = 1, Sig_y = function(L) sqrt(L), sig_z = 1){
my_load <- function(s) ReviewLoad_wDesk(k = k, v = v, z = z, sig_x = sig_x, sig_y = s, sig_z = sig_z)
# recall that interval isn't so important if we can specify the direction of the crossing
sig_y_hat <- uniroot(f = function(s) Sig_y(my_load(s)) - s, interval = c(0.5, 1), extendInt = "downX")$root
my_equilib <- ConstantVarEquilibrium_wDesk(k = k , v = v, z = z, sig_x = sig_x, sig_y = sig_y_hat, sig_z = sig_x)
ans <- c(my_equilib, sig_y_hat)
names(ans)[5] <- "sig_y_hat"
ans
}
Avg_Accepted_Type_wDesk <- function(x = -Inf, y = -Inf, z = -Inf, sig_x = 1, sig_y = 1, sig_z = 1){  # see p. 5/95
# Compute E[\theta | X > x, Y > y, Z > z]
require(tmvtnorm)
# --- build Σ_22 for (X,Y,Z) ---
S22 <- matrix(1, nrow = 3, ncol = 3)
diag(S22) <- 1 + c(sig_x^2, sig_y^2, sig_z^2)
# --- truncation limits ---
lower <- c(x, y, z)
upper <- rep(Inf, 3)
# --- compute truncated moments of W=(X,Y,Z) ---
# that is, E[W | W > (x,y,z)]
mW <- mtmvnorm(mean  = rep(0, 3),
sigma = S22,
lower = lower,
upper = upper,
doComputeVariance = F,
pmvnorm.algorithm = Miwa)$tmean
# --- regression coeffs β = Σ_12 Σ_22⁻¹, where Σ_12 = Cov(A, W) = (1,1,1) ---
beta <- matrix(1, nrow = 1, ncol = 3) %*% solve(S22)
# --- final conditional expectation ---
as.numeric(beta %*% mW)
}
JournalUtility_wDesk <- function(k = 0.2, v = 3, z = -Inf, sig_x = 1, Sig_y = function(L) 0.25 + sqrt(L), sig_z = 1){
my_equilib <- ChangingVarEquilibrium_wDesk(k = k, v = v, z = z, sig_x = sig_x, Sig_y = Sig_y, sig_z = sig_z)
x_hat <- AuthorX(my_equilib["q_hat"], sig_x = sig_x)
Avg_Accepted_Type_wDesk(x_hat, my_equilib["y_hat"], z, sig_x, my_equilib["sig_y_hat"], sig_z)
}
PlotJournalUtilityVsZ <- function(z_lo, z_hi, nz = 20, k = 0.2, v = 3, sig_x = 1,
Sig_y = function(L) 0.25 + sqrt(L), sig_z = 1, add = FALSE, ...){
z_max <- Find_Max_z(k = k, v = v, sig_x = sig_x, sig_z = sig_z)
if (z_hi > z_max) z_hi <- z_max * 0.9
zvals <- seq(from = z_lo, to = z_hi, length = nz)
uvals <- double(length = length(zvals))
# max_journal_quality <- MaxJournalQuality(k = k, author_dist = author_dist)
# set up the next report threshold (20%, 40%, …, 100%)
next_report <- 0.2
for (i in seq(along = zvals)) {
uvals[i] <- JournalUtility_wDesk(k = k, v = v, z = zvals[i], sig_x = sig_x, Sig_y = Sig_y, sig_z = sig_z)
if ((i / length(zvals)) >= next_report) {
cat(sprintf("%f%% complete\n", next_report * 100))
next_report <- next_report + 0.2
}
}
if (!add) plot(zvals, uvals, type = "p", xlab = "desk-rejection cut-off, z", ylab = "raw journal utility", ...)
else lines(zvals, uvals, ...)
}
OptimizeZ <- function(z_lo, z_hi, k = 0.2, v = 3,
sig_x = 1, Sig_y = function(L) 0.25 + sqrt(L), sig_z = 1,
tol = .Machine$double.eps^0.25){
z_max <- Find_Max_z(k = k, v = v, sig_x = sig_x, sig_z = sig_z)
if (z_hi > z_max) z_hi <- z_max * 0.99
u <- function(z) JournalUtility_wDesk(k = k, v = v, z = z, sig_x = sig_x, Sig_y = Sig_y, sig_z = sig_z)
z_hat <- optimize(u, interval = c(z_lo, z_hi), maximum = TRUE, tol = tol)$maximum
my_equilib <- ChangingVarEquilibrium_wDesk(k = k, v = v, z = z_hat, sig_x = sig_x, Sig_y = Sig_y, sig_z = sig_z)
ans <- c(my_equilib, z_hat)
names(ans)[6] <- "z_hat"
ans
}
600-65.01-11.87+12707/57
600-65.01-11.87+12707.57
13230.69-4297.05
2550/31
2550/31 * 26
2550/31 * 27
(82 + 84 + 81)/285
(82 + 84 + 96)/3
benefit <- function(r) sqrt(r)  # benefit to receiving exactly r letters
prob_letter_approx <- function(lam) ifelse(lam == 0, 1, (1 - exp(-lam)) / lam)
prob_letter <- function(C, W, l, abar) {
# C case managers, each of whom extends abar invitations
# W writers, each of whom will write at most l letters
# see p. 6/135
pbinom(l - 1, size = C - 1, prob = abar / W) + ((l * W) / (C * abar)) * (1 - pbinom(l, size = C, prob = abar / W))
}
prob_letter(10, 20, 5, 4)
prob_letter_approx(.4)
#----------- Chat GPT code, use to check -------------------------------
# -- Acceptance probability p(abar) using exact Binomial(M-1, abar/W) --
prob_letter_gpt <- function(C, W, l, abar) {
p_hit <- abar/W  # probability that one of the other C-1 managers invites any single writer
# precompute binomial pmf for k = 0..(M-1)
kmf <- dbinom(0 : (C - 1), size = C - 1, prob = p_hit)
# invited writer already has k invites from others;
# if k < l  -> accepts for sure; else accepts with prob = l/(k+1)
acc_prob <- ifelse(0 : (C - 1) < l, 1, l/( (0 : (C - 1)) + 1 ))
sum( kmf * acc_prob )
}
#----------- end Chat GPT code -------------------------------
prob_letter_gpt(10, 20, 5, 4)
prob_letter(100, 200, 5, 4)
prob_letter_approx(.4)
prob_letter(10, 100, 1, 4)
prob_letter_approx(10, 100, 1, 4)
prob_letter_approx(.4)
PlotBestResponse_approx <- function(gam = 0, c = 0, p_min = 0.1, p_step = 0.01, x_lim = 1, do_print = F) {
# this is a really fucking clumsy piece of code, but it's the best that I can do right now
if(do_print) {
pdf(file = "C:/Users/krgross/Documents/Projects/meltdown/figures/invitation_game.pdf", width = 4, height = 3)
par(oma = rep(0, 4), mar = c(5, 4, 1, 1))
}
p_vals <- seq(from = p_min, to = 1, by = p_step)
best_responses <- double(length = length(p_vals))
for (i in seq(along = p_vals)) best_responses[i] <- BestResponse(p = p_vals[i], gam = gam, c = c)
if (any(abs(diff(best_responses)) > 1)) stop("p_step is too small.  The best response changes too quickly.")
if (all(abs(diff(best_responses)) == 0)) stop("best response is the same for all values of p.")
change_indices <- which(abs(diff(best_responses)) == 1) # indices of p_vals where a change occurs in the best response.
indifferent_p_vals <- indifferent_l_vals <- double(length = length(change_indices))
for (i in seq(along = change_indices)) {
indifferent_p_vals[i] <- indifferent_p(p_lo = p_vals[change_indices[i]], p_hi = p_vals[change_indices[i] + 1], gam = gam, c = c)
indifferent_l_vals[i] <- find_lambda(indifferent_p_vals[i])
}
plot(c(0, x_lim), c(0, 10), type = "n", las = 1,
xaxs = "i", yaxs = "i", bty = "l", xlab = "community case load (C/L)", ylab = "avg. no of invitations per case")
for (i in seq(along = indifferent_l_vals)) {
to_plot <- function(x) indifferent_l_vals[i] / x
curve(to_plot, add = T, from = 0, to = x_lim)
if (i == 1) segments(x_lim, best_responses[change_indices[i]], indifferent_l_vals[i] / best_responses[change_indices[i]], best_responses[change_indices[i]], col = "red", lwd = 2)
else segments(indifferent_l_vals[i - 1] / best_responses[change_indices[i]], best_responses[change_indices[i]], indifferent_l_vals[i] / best_responses[change_indices[i]], best_responses[change_indices[i]], col = "red", lwd = 2)
}
segments(0, best_responses[change_indices[i] + 1], indifferent_l_vals[i] / best_responses[change_indices[i] + 1], best_responses[change_indices[i] + 1], col = "red", lwd = 2)
if(do_print) dev.off()
}
source("~/Projects/invitation game/invitation-game-v3.R", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
find_equilibria_beta(k = 4, n = 6, 1, 1)
?beta
?dbeta
find_equilibria_beta(k = 4, n = 6, 1, 5)
find_equilibria_beta(k = 4, n = 6, 1, 10)
find_equilibria_beta(k = 4, n = 10, 1, 10)
?dbinom
?curve
source("~/.active-rstudio-document", echo=TRUE)
find_equilibria_beta(k = 4, n = 6, 1, 10)
source("~/.active-rstudio-document", echo=TRUE)
find_equilibria_beta(k = 4, n = 6, 1, 10)
source("~/.active-rstudio-document", echo=TRUE)
debug(find_equilibria_beta)
find_equilibria_beta(k = 4, n = 6, 1, 10)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
debug(find_equilibria_beta)
find_equilibria_beta(k = 4, n = 6, 1, 10)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 6, 1, 10)
find_equilibria_beta(k = 4, n = 7, 1, 10)
find_equilibria_beta(k = 4, n = 10, 1, 10)
find_equilibria_beta(k = 4, n = 100, 1, 10)
find_equilibria_beta(k = 4, n = 6, 1, 10)
find_equilibria_beta(k = 4, n = 5, 1, 10)
find_equilibria_beta(k = 4, n = 4, 1, 10)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 4, 1, 10)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 4, 1, 10)
abline(h=1)
find_equilibria_beta(k = 4, n = 4, 1, 10, deadweight = 0.05)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 4, 1, 10, deadweight = 0.05)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 4, 1, 10, deadweight = 0.05)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 4, 1, 10, deadweight = 0.05)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(k = 4, n = 4, 1, 10, deadweight = 0.05)
(.857)^4
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_dean_success(k = 4, n_max = 10, 1, 5, deadweight = 0.2)
find_dean_success(k = 4, n_max = 15, 1, 5, deadweight = 0.2)
find_dean_success(k = 4, n_max = 25, 1, 5, deadweight = 0.2)
find_dean_success(k = 4, n_max = 55, 1, 5, deadweight = 0.2)
find_dean_success(k = 4, n_max = 55, 1, 5, deadweight = 0.1)
find_dean_success(k = 4, n_max = 55, 1, 10, deadweight = 0.1)
find_dean_success(k = 4, n_max = 55, 1, 10, deadweight = 0.2)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(n = 5, 1, 5)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
debug(find_equilibria_beta)
find_equilibria_beta(n = 5, 1, 5)
benefit_from_accept(0.2)
debug(benefit_from_accept)
benefit_from_accept(0.2)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(n = 5, 1, 5)
debug(find_equilibria_beta)
find_equilibria_beta(n = 5, 1, 5)
debug(benefit_from_accept)
benefit_from_accept(0.1)
dbinom(n_other_accepts, size = n - 1, prob = prob_accept) * marginal_accept_benefit
undebug(benefit_from_accept)
benefit_from_accept(0.2)
find_equilibria_beta(n = 5, 1, 5)
debug(benefit_from_accept)
benefit_from_accept(0)
undebug(benefit_from_accept)
benefit_from_accept(1)
curve(function(q) benefit_from_accept(q), from = 0, to = 1, xlab = "c", ylab = "benefit_from_accept", ylim = c(0, 1))
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(n = 5, 1, 5)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_beta(n = 5, 1, 5)
debugonce(find_equilibria_beta)
find_equilibria_beta(n = 5, 1, 5)
find_equilibria_beta(n = 5, 1, 5)
debugonce(find_equilibria_beta)
find_equilibria_beta(n = 5, 1, 5)
uniroot(g, lower = 0, upper = 1, extendInt = "downX")
abline(v = .Last.value$root)
?dgamma
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_gamma(5, 1)
debugonce(find_equilibria_gamma)
find_equilibria_gamma(5, 1)
debugonce(find_equilibria_gamma)
find_equilibria_gamma(5, 1)
c.star
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_equilibria_gamma(5, 1)
find_equilibria_gamma(10, 1)
find_equilibria_gamma(20, 1)
find_equilibria_gamma(200, 1)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_dean_success(n_max = 20, shape = .5)
source("~/Projects/invitation game/invitation-game-v4.R", echo=TRUE)
find_dean_success(n_max = 20, shape = .5)
.9^3
source("~/.active-rstudio-document", echo=TRUE)
longway(10, .3)
source("~/.active-rstudio-document", echo=TRUE)
longway(10, .3)
shortway(10, .3)
source("~/.active-rstudio-document", echo=TRUE)
max_pivot_prob(10, 2)
max_pivot_prob(10, 3)
max_pivot_prob(10, 4)
max_pivot_prob(10, 5)
max_pivot_prob(10, 6)
max_pivot_prob(10, 7)
max_pivot_prob(10, 8)
max_pivot_prob(10, 0)
max_pivot_prob(10, 21)
max_pivot_prob(10, 1)
516.49-10.7+12707.57
.Last.value - 3110.63
126.9/.9
86.4/.9
2550 * (1 + 27 / 31)
2550 * (1 + 27 / 31) + 300
2550 * 28/30
2380+2221+300
161.1/.9
118.8/.9
82.5*.6 + 86*.4
getwd()
setwd("C:/Users/krgross/Documents/GitHub/st512-course-notes/")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
install.packages("bookdown")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
moth2 <- read.table("data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
elogit <- function(x) log(x / (1 - x))
moth2$elogit.diff <- with(moth2, elogit(d.removed / d.placed) - elogit(l.removed / l.placed))
fm1 <- lm(elogit.diff ~ distance, data = moth2)
with(moth2, plot(elogit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
confint(fm1)
require(geepack)
moth <- read.table("data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
contrasts(moth$morph) <- contr.treatment(n = 2, base = 2)
fm2 <- geeglm(cbind(removed, placed - removed) ~ distance * morph,
family = binomial(link = "logit"),
data   = moth,
id     = location,
corstr = "exchangeable")
summary(fm2)
inv.logit <- function(x) exp(x) / (1 + exp(x))
light.fit <- function(d) inv.logit(-0.71472 - 0.00938 * d)
dark.fit <- function(d) inv.logit(-0.71472 - 0.41024 + (-0.00938 + 0.02776) * d)
curve(dark.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
ylim = c(0.15, 0.5))
curve(light.fit, from = min(moth$distance), to = max(moth$distance),
xlab = "distance from city center (km)",
ylab = "proportion removed",
add = TRUE,
lty = "dashed")
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
options(digits = 7)
dark.fit(20)
require(lme4)
fm3 <- glmer(cbind(removed, placed - removed) ~ distance * morph + (1 | location),
family = binomial(link = "logit"),
data = moth)
summary(fm3)
confint(fm3, parm = c("distance:morph1"))
deviance(fm3)
df.residual(fm3)
dark.linpred.glmm <- function(d) -0.71979 - 0.41113 + (-0.00934 + 0.02782) * d
dark.fit.glmm <- function(d) inv.logit(dark.linpred.glmm(d))
dark.fit.glmm(20)
linpred.sample <- rnorm(1e6, mean = dark.linpred.glmm(20), sd = 0.1072)
prob.sample <- inv.logit(linpred.sample)
(conditional.mean <- inv.logit(dark.linpred.glmm(20)))
(marginal.mean <- mean(prob.sample))
par(mfrow = c(1, 2))
hist(linpred.sample, breaks = 50, xlab = "linear predictor", main = "")
hist(prob.sample, breaks = 50, xlab = "removal probability", main = "")
abline(v = conditional.mean, col = "darkorange", lwd =2)
abline(v = marginal.mean, col = "blue", lwd = 2)
linpred.sample <- rnorm(1e6, mean = dark.linpred.glmm(20), sd = 10 * 0.1072)
prob.sample <- inv.logit(linpred.sample)
(conditional.mean <- inv.logit(dark.linpred.glmm(20)))
(marginal.mean <- mean(prob.sample))
par(mfrow = c(1, 2))
hist(linpred.sample, breaks = 50, xlab = "linear predictor", main = "")
hist(prob.sample, breaks = 50, xlab = "removal probability", main = "")
abline(v = conditional.mean, col = "darkorange", lwd =2)
abline(v = marginal.mean, col = "blue", lwd = 2)
require(R2jags)
moth.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j]   ~ dbin(p[j], n[j])      # data distribution
p[j]   <- ilogit(eta[j])      # inverse link
eta[j] <- a[morph[j]] + b[morph[j]] * dist[j] + L[loc[j]]  # linear predictor,
}
for (j in 1:7){  # random effects for location
L[j] ~ dnorm(0, tau_L)
}
a[1] ~ dnorm (0.0, 1E-6)       # priors for intercept
a[2] ~ dnorm (0.0, 1E-6)       # priors for intercept
b[1] ~ dnorm (0.0, 1E-6)       # prior for slope
b[2] ~ dnorm (0.0, 1E-6)       # prior for slope
tau_L   ~ dgamma (0.01, 0.01)    # prior for location-level random effect
sd_L   <- pow(tau_L, -1/2)
b.diff <- b[1] - b[2]
}
jags.data <- list(y     = moth$removed,
n     = moth$placed,
dist  = moth$distance,
loc   = as.numeric(moth$location),
morph = as.numeric(moth$morph),
J     = nrow(moth))
jags.params <- c("a[1]", "a[2]", "b[1]", "b[2]", "b.diff", "sd_L")
jags.inits <- function(){
list("tau_L" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = moth.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
print(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
(post.mean   <- apply(mcmc.output, 2, mean))
HPDinterval(as.mcmc(mcmc.output['b.diff']))
bayesplot::mcmc_areas(mcmc.output,
pars = c("b.diff"),
prob = 0.95)
table(mcmc.output$b.diff > 0)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.2'] + post.mean['b.2'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = light$distance, y = light$prop.removed, pch = 16)
#--------- dark morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.1'] + post.mean['b.1'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = dark$distance, y = dark$prop.removed, pch = 16)
rm(list = ls())
require(lme4)
require(lattice)
tick <- read.table("data/tick.txt", head = T)
names(tick) <- c("index", "ticks", "brood", "elevation", "yr", "loc")
tick$index <- as.factor(tick$index)
tick$brood <- as.factor(tick$brood)
tick$yr    <- as.factor(tick$yr)
tick$loc   <- as.factor(tick$loc)
# center and scale elevation
tick$elev.z <- with(tick, (elevation - mean(elevation)) / sd(elevation))
fm1  <- glmer(ticks ~ yr + elev.z + (1 | loc) + (1 | brood) + (1 | index),
family = "poisson",
data = tick)
summary(fm1)
pp <- profile(fm1)
confint(pp)
xyplot(pp, absVal = TRUE)
splom(pp)
options(digits = 7)
fm2  <- glmer(ticks ~ yr + elev.z + (1 | brood) + (1 | index),
family = "poisson",
data = tick)
anova(fm2, fm1)
par(mfrow = c(1, 3))
plot.subset <- function(year, a, b) {
with(tick, plot(log(ticks + 1) ~ elev.z, type = "n", main = year))
with(subset(tick, yr == year), points(jitter(log(ticks + 1)) ~ elev.z))
fit <- function(x) log(1 + exp(a + b * x))
curve(fit, from = min(tick$elev.z), to = max(tick$elev.z), add = TRUE, col = "red")
}
plot.subset("95", a = 0.3728, b = -0.8543)
plot.subset("96", a = 0.3728 + 1.1804, b = -0.8543)
plot.subset("97", a = 0.3728 - 0.9787, b = -0.8543)
rdu <- read.table("data/rdu-temperature.txt", head = T)
# remove NA's, coded as -99
with(rdu, table(temp == -99))
rdu <- subset(rdu, temp > -99)
with(rdu, plot(temp ~ time, type = "l", xlab = "day"))
require(mgcv)
fm1 <- gamm(temp ~ s(doy, bs = "cc", k = 20) + s(time), data = rdu, correlation = corAR1(form = ~ 1 | yr))
summary(fm1$lme)
summary(fm1$gam)
plot(fm1$gam)
fm2 <- gamm(temp ~ s(doy, bs = "cc", k = 20) + time, data = rdu, correlation = corAR1(form = ~ 1 | yr))
summary(fm2$lme)
fm1a <- gam(temp ~ s(doy, bs = "cc", k = 20) + s(time), data = rdu)
plot(fm1a)
abline(h = 0, col = "red")
require(gamm4)
fm4  <- gamm4(ticks ~ yr + s(elev.z), random = ~ (1 | loc) + (1 | brood) + (1 | index),
family = "poisson",
data = tick)
summary(fm4$mer)
summary(fm4$gam)
plot(fm4$gam)
fm5  <- gam(ticks ~ yr + s(elev.z),
family = "poisson",
data = tick)
plot(fm5)
getwd()
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
