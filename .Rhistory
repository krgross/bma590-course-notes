with(st19, plot(log(sources) ~ depth))
st19.fit <- predict(st19.sspline,
newdata = data.frame(depth = depth.vals),
se      = TRUE)
lines(x = depth.vals, y = st19.fit$fit)
lines(x = depth.vals, y = st19.fit$fit + qt(0.975, df = 39.5) * st19.fit$se.fit, lty = "dashed")
lines(x = depth.vals, y = st19.fit$fit + qt(0.025, df = 39.5) * st19.fit$se.fit, lty = "dashed")
par(mfrow = c(2, 2))
rm(list = ls())
require(mgcv)
bird <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/ZuurDataMixedModelling/Loyn.txt", head = T)
summary(bird)
bird <- bird[, -1]
pairs(bird)
bird$L.AREA <- log(bird$AREA)
bird$L.DIST <- log(bird$DIST)
bird$L.LDIST <- log(bird$LDIST)
bird$YR.ISOL <- 1987 - bird$YR.ISOL
bird <- bird[, c("ABUND", "L.AREA", "L.DIST", "L.LDIST", "YR.ISOL", "ALT", "GRAZE")]
pairs(bird)
bird.am1 <- mgcv::gam(ABUND ~ s(L.AREA) + s(L.DIST) + s(L.LDIST) + s(YR.ISOL) +
s(GRAZE) + s(ALT), data = bird)
bird.am1 <- mgcv::gam(ABUND ~ s(L.AREA) + s(L.DIST) + s(L.LDIST) +
s(YR.ISOL) + GRAZE + s(ALT),
data = bird)
summary(bird.am1)
par(mfrow = c(2, 3))
plot(bird.am1)
bird.am2 <- gam(ABUND ~ s(L.AREA) + GRAZE, data = bird)
GRAZ
bird.am2 <- gam(ABUND ~ s(L.AREA) + GRAZE, data = bird)
summary(bird.am2)
plot(bird.am2)
bird.am3 <- gam(ABUND ~ s(L.AREA), data = bird)
plot(x = bird$GRAZE, y = bird.am3$residuals)
abline(h = 0, lty = "dashed")
rdu <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/rdu-temperature.txt", head = T)
# remove NA's, coded as -99
with(rdu, table(temp == -99))
rdu <- subset(rdu, temp > -99)
yr_avg <- with(subset(rdu, yr < 2025), aggregate(temp, list(yr), FUN = mean))
names(yr_avg) <- c("year", "avg_temp")
with(yr_avg, plot(avg_temp ~ year))
require(nlme)
birds <- read.table("C:/Users/krgross/Documents/Teaching/bma590/general/ZuurDataMixedModelling/Hawaii.txt", head = T)
## extract moorhen data
moorhen <- birds[, c("Year", "Rainfall", "Moorhen.Kauai")]
## rename variables
names(moorhen) <- c("year", "rainfall", "abundance")
## remove NAs
moorhen <- na.omit(moorhen)
head(moorhen)
with(moorhen, plot(abundance ~ year))
with(moorhen, plot(log(abundance) ~ year))
with(moorhen, plot(log(abundance) ~ rainfall))
fm1 <- nlme::gls(log(abundance) ~ rainfall + year,
data = moorhen)
plot(residuals(fm1) ~ moorhen$year)
abline(h = 0, lty = "dotted")
acf(residuals(fm1))
fm2 <- nlme::gls(log(abundance) ~ rainfall + year,
data = moorhen,
correlation = corAR1(form = ~ year))
acf(residuals(fm2, type = "normalized"))
data(Dyestuff)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm1 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm1)
ranef(fm1)
(batch.conditional.modes <- (fixef(fm1) + ranef(fm1)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm1 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm1)
ranef(fm1)
(batch.conditional.modes <- (fixef(fm1) + ranef(fm1)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
fm1.ML <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff, REML = FALSE)
summary(fm1.ML)
pr <- profile(fm1.ML)
lattice::xyplot(pr, absVal = TRUE)
lattice::xyplot(pr)
confint(pr, level = 0.95)
confint(pr, level = 0.99)
lattice::splom(pr)
fm2 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm2)
1527.5 + 19.38 *  qt(c(0.025, 0.975), df = 5)
lattice::dotplot(ranef(fm2, condVar = TRUE))
moth <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
with(moth, plot(removed / placed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
logit <- function(x) log(x / (1 - x))
moth$logit_removed <- with(moth, logit(removed / placed))
with(moth, plot(logit_removed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(logit_removed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(logit_removed ~ distance, pch = 1))
mm1 <- lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
summary(mm1)
abline(a = -1.1233, b = 0.01819) # dark fit
abline(a = -1.1233 + 0.3738, b = 0.01819 - 0.02758, lty = "dashed")  # light fit
pr <- profile(mm1)  # remember this is the ML fit
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = .95)
mm1a <- lmerTest::lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
summary(mm1a)
moth2 <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
logit <- function(x) log(x / (1 - x))
moth2$logit.diff <- with(moth2, logit(d.removed / d.placed) - logit(l.removed / l.placed))
fm1 <- lm(logit.diff ~ distance, data = moth2)
with(moth2, plot(logit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
data(Dyestuff2)
summary(Dyestuff2)
with(Dyestuff2, stripchart(Yield ~ Batch, pch = 16))
require(nlme)
fm5 <- gls(Yield ~ 1, data = Dyestuff2, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm5)
fm6 <- lme4::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
summary(fm6)
pr <- profile(fm6)  # remember this is the ML fit
lattice::xyplot(pr, absVal = TRUE)
require(R2jags)
rm(list = ls())
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/general/ZuurDataMixedModelling/RIKZ.txt", head = T)
rikz$fBeach <- as.factor(rikz$Beach)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
fm0 <- lm(sqrt(Richness) ~ fBeach + NAP, data = rikz)
summary(fm0)
anova(fm0)
fm0.temp <- lm(sqrt(Richness) ~ fBeach + NAP - 1, data = rikz)
coef(fm0.temp)
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Fixed-effects fit, additive model"))
legend("topright", leg = 1:9, pch = 1:9)
b <- coef(fm0)["NAP"]
for(i in 1:9){
abline(a = coef(fm0.temp)[i], b = b, col = "red", lty = "dotted")
}
fm1 <- lmerTest::lmer(sqrt(Richness) ~ NAP + (1 | fBeach),
data = rikz)
summary(fm1)
(beach.conditional.modes <- (fixef(fm1)["(Intercept)"] + ranef(fm1)$fBeach$`(Intercept)`))
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Random intercepts fit"))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = beach.conditional.modes[i], b = b, col = "red", lty = "dotted")
}
# test for significance of random differences among beaches
fm1b <- lm(sqrt(Richness) ~ NAP, data = rikz)
anova(fm1, fm1b)
fm0b <- lm(sqrt(Richness) ~ fBeach * NAP, data = rikz)
summary(fm0b)
anova(fm0b)
fm0b.temp <- lm(sqrt(Richness) ~ fBeach + fBeach:NAP - 1, data = rikz)
(fixed.params <- data.frame(beach     = 1:9,
intercept = coef(fm0b.temp)[1:9],
slope     = coef(fm0b.temp)[10:18]))
row.names(fixed.params) <- NULL
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Fixed-effects fit, with beach-NAP interaction"))
legend("topright", leg = 1:9, pch = 1:9)
for(i in 1:9){
abline(a = fixed.params$intercept[i], b = fixed.params$slope[i],
col = "red", lty = "dotted")
}
fm2 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 + NAP | fBeach),
data = rikz)
summary(fm2)
anova(fm1, fm2)
fm2a <- lmerTest::lmer(sqrt(Richness) ~ NAP + (1 | fBeach) + (0 + NAP | fBeach),
data = rikz)
summary(fm2a)
anova(fm1, fm2a, fm2)
(conditional.modes  <- data.frame(beach     = 1:9,
intercept = fixef(fm2a)["(Intercept)"] + ranef(fm2a)$fBeach$`(Intercept)`,
slope     = fixef(fm2a)["NAP"] + ranef(fm2a)$fBeach$`NAP`))
par(mfrow = c(1, 2))
with(fixed.params, plot(slope ~ intercept, main = "fixed-effects fit", pch = 1:9))
with(fixed.params, plot(slope ~ intercept, main = "conditional modes", type = "n"))
with(conditional.modes, points(slope ~ intercept, pch = 1:9))
points(fixef(fm2a)[1], fixef(fm2a)[2], pch = 16, col = "red", cex = 2)
par(mfrow = c(1, 1))
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach, main = "Random-coefficients fit"))
legend("topright", leg = 1:9, pch = 1:9)
for(i in 1:9){
abline(a = conditional.modes$intercept[i], b = conditional.modes$slope[i],
col = "red", lty = "dotted")
}
abline(a = fixef(fm2a)[1], b = fixef(fm2a)[2], col = "red", lwd = 2)
abline(a = fixef(fm2a)[1], b = fixef(fm2a)[2], col = "red", lwd = 2)
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = high.beaches, pch = high.beaches)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
summary(fm3)
fm4 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 + NAP| fBeach), data = rikz)
summary(fm4)
fm5 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach) + (0 + NAP | fBeach),
data = rikz)
summary(fm5)
anova(fm3, fm4, fm5)
pr <- profile(fm3)
lattice::xyplot(pr, absVal = T)
confint(pr)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
summary(fm3)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
legend("topright", leg = high.beaches, pch = high.beaches)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm1 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm1)
ranef(fm1)
(batch.conditional.modes <- (fixef(fm1) + ranef(fm1)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
fm1.ML <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff, REML = FALSE)
summary(fm1.ML)
pr <- profile(fm1.ML)
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = 0.95)
confint(pr, level = 0.99)
fm2 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm2)
lattice::splom(pr)
lattice::dotplot(ranef(fm2, condVar = TRUE))
moth <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth.txt", head = TRUE, stringsAsFactors = TRUE)
moth
with(moth, plot(removed / placed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(removed / placed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(removed / placed ~ distance, pch = 1))
logit <- function(x) log(x / (1 - x))
moth$logit_removed <- with(moth, logit(removed / placed))
with(moth, plot(logit_removed ~ distance, type = "n"))
with(subset(moth, morph == "dark"), points(logit_removed ~ distance, pch = 16))
with(subset(moth, morph == "light"), points(logit_removed ~ distance, pch = 1))
mm1 <- lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
mm1 <- lmer(logit_removed ~ distance + morph + distance:morph + (1 | location), data = moth)
summary(mm1)
abline(a = -1.1233, b = 0.01819) # dark fit
abline(a = -1.1233 + 0.3738, b = 0.01819 - 0.02758, lty = "dashed")  # light fit
pr <- profile(mm1)  # remember this is the ML fit
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = .95)
mm1a <- lmerTest::lmer(logit_removed ~ distance * morph + (1 | location), data = moth)
summary(mm1a)
moth2 <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/moth2.txt", head = TRUE, stringsAsFactors = TRUE)
head(moth2, n = 3)
logit <- function(x) log(x / (1 - x))
moth2$logit.diff <- with(moth2, logit(d.removed / d.placed) - logit(l.removed / l.placed))
fm1 <- lm(logit.diff ~ distance, data = moth2)
with(moth2, plot(logit.diff ~ distance,
xlab = "distance from city center (km)",
ylab = "difference in log odds of removal, dark - light"))
abline(h = 0, lty = "dashed")
abline(fm1)
summary(fm1)
getwd()
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
elephant <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/elephant.txt", head = T)
with(elephant, plot(matings ~ age, pch = 16))
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
(pseudo.R2 <- 1 - 51.012 / 75.372)
new.data <- data.frame(age = seq(from = min(elephant$age),
to   = max(elephant$age),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm1$fit, col = "red")
lines(x   = new.data$age,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
fm0 <- glm(matings ~ 1,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm0)
anova(fm0, fm1, test = "Chisq")
fm1a <- glm(matings ~ age + I(age^2),
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1a)
anova(fm0, fm1, fm1a)
fm2 <- glm(matings ~ age,
family = poisson(link = "identity"),
data = elephant)
fm2a <- glm(matings ~ age + I(age^2),
family = poisson(link = "identity"),
data   = elephant)  # log link is the default
anova(fm2, fm2a, test = "Chisq")
summary(fm2a)
predict.fm2 <- predict(fm2, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm2$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit - 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "deviance"),
xlab = "age",
ylab = "Deviance residuals")
abline(h = 0, lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "pearson"),
xlab = "age",
ylab = "Pearson residuals")
abline(h = 0, lty = "dashed")
fm3 <- glm(matings ~ age, family = quasipoisson(link = "identity"), data = elephant)
summary(fm3)
predict.fm3 <- predict(fm3, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm3$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm3$fit + qt(0.025, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm3$fit + qt(0.975, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
require(MASS)
fm4 <- glm.nb(matings ~ age, link = identity, data = elephant)
summary(fm4)
predict.fm4 <- predict(fm4, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm4$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm4$fit + 1.96 * predict.fm4$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm4$fit - 1.96 * predict.fm4$se.fit,
col = "blue",
lty = "dashed")
rm(list = ls())
boar <- read.table("C:/Users/krgross/Documents/Teaching/bma590/general/ZuurDataMixedModelling/Boar.txt", head = T)
# remove incomplete records
boar <- na.omit(boar)
# convert sex to a factor
boar$SEX <- as.factor(boar$SEX)
names(boar) <- c("tb", "sex", "age", "length")
summary(boar)
fm1 <- glm(tb ~ length,
family = binomial(link = "logit"),
data = boar)
summary(fm1)
with(boar, plot(tb ~ length))
new.data <- data.frame(length = seq(from = min(boar$length),
to   = max(boar$length),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
lines(x = new.data$length, y = predict.fm1$fit, col = "red")
lines(x   = new.data$length,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$length,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
pchisq(641.23, df = 492, lower.tail = FALSE)
fm1a <- glm(tb ~ length, family = binomial(link = "probit"), data = boar)
AIC(fm1, fm1a)
fm1b <- glm(tb ~ length, family = binomial(link = "cloglog"), data = boar)
AIC(fm1, fm1a, fm1b)
predict.fm1a <- predict(fm1a, newdata = new.data, type = "response", se.fit = TRUE)
predict.fm1b <- predict(fm1b, newdata = new.data, type = "response", se.fit = TRUE)
with(boar, plot(tb ~ length))
lines(x = new.data$length, y = predict.fm1$fit, col = "red", lwd = 2)
lines(x = new.data$length, y = predict.fm1a$fit, col = "blue", lwd = 2)
lines(x = new.data$length, y = predict.fm1b$fit, col = "forestgreen", lwd = 2)
legend("left",
leg = c("logit", "probit", "cloglog"),
col = c("red", "blue", "forestgreen"),
pch = 16)
fm2 <- glm(tb ~ sex * as.factor(age),
family = binomial,
data = boar)
summary(fm2)
with(boar, table(tb, age, sex))
fm3 <- glm(tb ~ length + sex + as.factor(age),
family = binomial,
data = boar)
summary(fm3)
fm4 <- update(fm3, . ~ . - as.factor(age))
anova(fm3, fm4, test = "Chisq")
summary(fm4)
deer <- read.table("C:/Users/krgross/Documents/Teaching/bma590/general/ZuurDataMixedModelling/Tbdeer.txt", head = T)
deer <- deer[, c(4, 5, 8:14)]
deer <- na.omit(deer)
deer$DeerPropTB <- with(deer, DeerPosTB / DeerSampledTB)
pairs(deer)
fm1 <- glm(cbind(DeerPosTB, DeerSampledTB - DeerPosTB) ~ OpenLand + ScrubLand + ReedDeerIndex,
family = binomial(link = "logit"),
data = deer)
summary(fm1)
fm2 <- glm(cbind(DeerPosTB, DeerSampledTB - DeerPosTB) ~ OpenLand + ScrubLand + ReedDeerIndex,
family = quasibinomial(link = "logit"),
data = deer)
summary(fm2)
fm3 <- update(fm2, . ~ . - ScrubLand)
summary(fm3)
fm4 <- update(fm3, . ~ . - OpenLand)
summary(fm4)
plot(DeerPropTB ~ ReedDeerIndex, data = deer, pch = 16)
new.data <- data.frame(ReedDeerIndex= seq(from = min(deer$ReedDeerIndex),
to   = max(deer$ReedDeerIndex),
length = 100))
predict.fm4 <- predict(fm4, newdata = new.data, type = "response", se.fit = TRUE)
lines(x = new.data$ReedDeerIndex, y = predict.fm4$fit, col = "red")
lines(x   = new.data$ReedDeerIndex,
y   = predict.fm4$fit - 1.96 * predict.fm4$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$ReedDeerIndex,
y   = predict.fm4$fit + 1.96 * predict.fm4$se.fit,
col = "red",
lty = "dashed")
