require(emdbook)
data("FirDBHFec")
fir <- FirDBHFec
rm(FirDBHFec)
names(fir)
fir <- fir[, c("WAVE_NON", "DBH", "TOTCONES")]
names(fir) <- c("wave", "dbh", "cones")
summary(fir)
head(fir)
fir <- na.omit(fir)
summary(fir)
with(fir, table(cones == round(cones)))
# round the non-integral values
fir$cones <- round(fir$cones)
# check
with(fir, table(cones == round(cones)))
par(mfrow = c(1, 2))
plot(cones ~ dbh, data = fir, type = "n", main = "wave")
points(cones ~ dbh, data = subset(fir, wave == "w"))
plot(cones ~ dbh, data = fir, type = "n", main = "non-wave")
points(cones ~ dbh, data = subset(fir, wave == "n"))
fir.neg.ll <- function(parms, x, y){
a <- parms[1]
b <- parms[2]
k <- parms[3]
my.mu <- a * x^b
ll.values <- dnbinom(y, size = k, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
(fir.reduced <- optim(f   = fir.neg.ll,
par = c(a = 1, b = 1, k = 1),
x   = fir$dbh,
y   = fir$cones))
a.mle <- fir.reduced$par[1]
b.mle <- fir.reduced$par[2]
k.mle <- fir.reduced$par[3]
par(mfrow = c(1, 1))  # don't break the next figure into two panels
with(fir, plot(cones ~ dbh))
dbh.vals <- seq(from = min(fir$dbh), to = max(fir$dbh), length = 100)
fit.vals <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals[i] <- a.mle * dbh.vals[i] ^ b.mle
}
lines(fit.vals ~ dbh.vals, col = "blue")
(aic.reduced <- 2 * fir.reduced$value + 2 * 3)
fir.alt.neg.ll <- function(parms, x, y){
a <- exp(parms[1])
b <- parms[2]
phi <- exp(parms[3])
my.mu <- a * x^b
ll.values <- dnbinom(y, size = phi * my.mu, mu = my.mu, log = TRUE)
-1 * sum(ll.values)
}
(fir.alt <- optim(f   = fir.alt.neg.ll,
par = c(a = 0, b = 1, phi = 0),
x   = fir$dbh,
y   = fir$cones))
(a.mle.alt <- exp(fir.alt$par[1]))
(b.mle.alt <- fir.alt$par[2])
(phi.mle.alt <- exp(fir.alt$par[3]))
fit.vals.alt <- double(length = length(dbh.vals))
for (i in seq(along = dbh.vals)) {
fit.vals.alt[i] <- a.mle.alt * dbh.vals[i] ^ b.mle.alt
}
par(mfrow = c(1, 1))
with(fir, plot(cones ~ dbh))
lines(fit.vals ~ dbh.vals, col = "blue")
lines(fit.vals.alt ~ dbh.vals, col = "red")
mu.vals <- seq(from = 0, to = max(fit.vals), length = 100)
mu.vals <- seq(from = 0, to = max(fit.vals), length = 100)
sd.vals.nb1 <- sqrt(mu.vals + mu.vals ^ 2 / k.mle)
sd.vals.nb2 <- sqrt(mu.vals * (1 + 1 / phi.mle.alt))
plot(mu.vals, sd.vals.nb1, xlab = "mean", ylab = "SD", type = "l", col = "blue")
lines(mu.vals, sd.vals.nb2, col = "red")
(aic.alt <- 2 * fir.alt$value + 2 * 3)
.2*.9/(,2*,9+.8*.005)
.2*.9/(.2*.9+.8*.005)
162 * .65
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
l.vals <- seq(from = 0, to = 2, length = 200)
plot(l.vals, dgamma(l.vals, shape = 197, rate = 281), type = "l")
lines(l.vals, dgamma(l.vals, shape = 1, rate = 1), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
197 /281
qgamma(0.5, shape = 197, rate = 281)
optimize(f = function(x) dgamma(x, shape = 197, rate = 281), interval = c(0.5, 1), maximum = TRUE)
qgamma(c(0.025, 0.975), shape = 197, rate = 281)
diff.in.pdf <- function(x){
upper <- qgamma(p = x, shape = 197, rate = 281)
lower <- qgamma(p = x - .95, shape = 197, rate = 281)
dgamma(upper, shape = 197, rate = 281) - dgamma(lower, shape = 197, rate = 281)
}
(upper.qtile <- uniroot(diff.in.pdf, interval = c(0.95, 1))$root)
(hpd.ci <- qgamma(p = c(upper.qtile - .95, upper.qtile), shape = 197, rate = 281))
(central.ci <- qgamma(c(0.025, 0.975), shape = 197, rate = 281))
abline(v = central.ci, lty = "dashed")
pgamma(2/3, shape = 197, rate = 281, lower.tail = FALSE)
plot(l.vals, dgamma(l.vals, shape = 196 + 50, rate = 100 + 280), type = "l",
xlab = expression(lambda), ylab = "")
lines(l.vals, dgamma(l.vals, shape = 50, rate = 100), lty = "dashed")
abline(v = 0.7, col = "red")
legend("topleft", leg = c("prior", "posterior"),
lty = c("dashed", "solid"))
source('~/Teaching/bma590/bma590-fall21/r/class08.R')
175 / 449
449 * .4
180 / 449
185/456
456*.4
deer <- read.csv("~/Teaching/data/deer.txt", sep="")
View(deer)
fm1 <- with(deer, lm(deer.total ~ log(house.dens) + log(pop.dens)))
summary(fm1)
fm2 <- with(deer, lm(deer.total ~ house.dens + pop.dens)
)
summary(fm2)
fm3 <- with(deer, lm(deer.total ~ log(pop.dens)))
plot(resid$fm3 ~ log(deer$house.dens))
plot(fm3$residuals ~ log(deer$house.dens))
fm4 <- lm(fm3$residuals ~ log(deer$house.dens))
summary(fm4)
summary(fm3)
fm5 <- with(deer, lm(deer.total ~ log(house.dens)))
summary(fm5)
fm6 <- lm(fm5$residuals ~ log(deer$road.dens))
fm6 <- lm(fm5$residuals ~ log(deer$pop.dens))
summary(fm6)
pop.only <- lm(deer.take ~ log(pop.dens) + rd.dens, data = deer)
pop.only <- lm(deer.total ~ log(pop.dens) + rd.dens, data = deer)
house.only <- lm(deer.total ~ log(house.dens) + rd.dens, data = deer)
summary(pop.only)
summary(house.only)
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
require(R2jags)
horse.model <- function() {
for (j in 1:J) {             # J = 280, number of data points
y[j] ~ dpois (lambda)      # data model:  the likelihood
}
lambda ~ dgamma (0.01, 0.01) # prior
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
}
jags.data <- list(y = horse$deaths, J = length(horse$deaths))
jags.params <- c("lambda")
jags.inits <- function(){
list("lambda" = rgamma(0.01, 0.01))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = horse.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
median(mcmc.output$lambda)
quantile(mcmc.output$lambda, c(.025, .975))
median(mcmc.output$lambda)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
densityplot(mcmc.output)
densityplot(mcmc.output$lambda)
rm(list = ls())
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
horse <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/horse.txt",
header = TRUE,
stringsAsFactors = TRUE)
require(R2jags)
horse.model <- function() {
for (j in 1:J) {             # J = 280, number of data points
y[j] ~ dpois (lambda)      # data model:  the likelihood
}
lambda ~ dgamma (0.01, 0.01) # prior
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
}
jags.data <- list(y = horse$deaths, J = length(horse$deaths))
jags.params <- c("lambda")
jags.inits <- function(){
list("lambda" = rgamma(0.01, 0.01))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = horse.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
rm(list = ls())
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
cor(mcmc.output)
cor(mcmc.output[, -c(3:4)])
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
cor(mcmc.output)
cor(mcmc.output[, -c(3:4)])
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
rf <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
library(hexbin)
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
with(jagsfit$BUGSoutput$sims.list, hexbinplot(b1 ~ b0, colramp = rf))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
cor(mcmc.output)
cor(mcmc.output[, -c(3:4)])
cricket$temp.ctr <- cricket$temperature - mean(cricket$temperature)
jags.data <- list(y = cricket$chirps,
x = cricket$temp.ctr,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
library(hexbin)
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
with(jagsfit$BUGSoutput$sims.list, hexbinplot(b1 ~ b0, colramp = rf))
with(jagsfit$BUGSoutput$sims.list, cor(b0, b1))
require(rstanarm)
stanarm.cricket.fit <- stan_glm(chirps ~ temp.ctr, data = cricket, family = gaussian, seed = 1)
print(stanarm.cricket.fit, digits = 3)
rm(list = ls())
require(R2jags)
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
str(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
head(mcmc.output)
medain(mcmc.output$sigma)
median(mcmc.output$sigma)
plot(density(mcmc.output$b1))
plot(density(mcmc.output$sigma))
plot(chirps ~ temperature, data = cricket, type = "n")
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.25))
}
with(cricket, points(chirps ~ temperature, pch = 16))
avg.chirps.85 <- with(mcmc.output, b0 + b1 * 85)
summary(avg.chirps.85)
quantile(avg.chirps.85, probs = c(.025, 0.975))
plot(density(avg.chirps.85))
n.sims <- nrow(mcmc.output)
new.errors <- with(mcmc.output, rnorm(n.sims, mean = 0, sd = sigma))
new.chirps.85 <- with(mcmc.output, b0 + b1 * 85) + new.errors
plot(density(new.chirps.85))
summary(new.chirps.85)
quantile(new.chirps.85, probs = c(.025, 0.975))
rm(list = ls())
require(R2jags)
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
summary(cricket.slr)
plot(chirps ~ temperature, data = cricket)
abline(cricket.slr)
cricket.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dnorm (mu[j], tau)  # data model:  the likelihood
# note that BUGS / JAGS uses precision
# instead of variance
mu[j] <- b0 + b1 * x[j]    # compute the mean for each observation
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau ~ dgamma (0.01, 0.01)    # prior for tau (inverse of the error variance)
# note that BUGS / JAGS parameterizes
# gamma by shape, rate
sigma <- pow(tau, -1/2)      # the SD of the errors
}
jags.data <- list(y = cricket$chirps,
x = cricket$temperature,
J = nrow(cricket))
jags.params <- c("b0", "b1", "tau", "sigma")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = cricket.model,
n.chains           = 3,
n.iter             = 5000)
print(jagsfit)
traceplot(jagsfit)
str(jagsfit)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
summary(mcmc.output)
plot(density(mcmc.output$b1))
head(mcmc.output)
plot(chirps ~ temperature, data = cricket, type = "n")
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
with(mcmc.output, abline(a = b0[i], b = b1[i], col = "deepskyblue", lwd = 0.25))
}
with(cricket, points(chirps ~ temperature, pch = 16))
?rbeta
source('~/Teaching/bma590/bma590-fall21/r/class11.R')
## download the data from the book's website
isit <- read.table("../data/ISIT.txt", head = T)
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
## download the data from the book's website
isit <- read.table("data/ISIT.txt", head = T)
## extract the data from station 16
st16 <- subset(isit, Station == 16)
## retain just the variables that we want, and rename
st16 <- st16[, c("SampleDepth", "Sources")]
names(st16) <- c("depth", "sources")
with(st16, plot(sources ~ depth))
## fit a loess smoother using the default settings
st16.lo <- loess(sources ~ depth, data = st16)
st16.lo <- loess(sources ~ depth, data = st16)
st16.lo <- loess(sources ~ depth, data = st16)
summary(st16.lo)
depth.vals <- with(st16, seq(from   = min(depth),
to     = max(depth),
length = 100))
st16.fit <- predict(object  = st16.lo,
newdata = depth.vals,
se      = TRUE)
lines(x = depth.vals, y = st16.fit$fit, col = "blue")
depth.vals <- with(st16, seq(from   = min(depth),
to     = max(depth),
length = 100))
st16.fit <- predict(object  = st16.lo,
newdata = depth.vals,
se      = TRUE)
with(st16, plot(sources ~ depth))
lines(x = depth.vals, y = st16.fit$fit, col = "blue")
# add 95% error bars
lines(x   = depth.vals,
y   = st16.fit$fit + st16.fit$se.fit * qt(p = .975, df = st16.fit$df),
col = "blue",
lty = "dashed")
lines(x   = depth.vals,
y   = st16.fit$fit - st16.fit$se.fit * qt(p = .975, df = st16.fit$df),
col = "blue",
lty = "dashed")
## see what the fit returns; maybe the residuals are already there
names(st16.lo)  # they are!
plot(st16.lo$residuals ~ st16$depth)
abline(h = 0, lty = "dotted")
PlotLoessFit <- function(x, y, return.fit = FALSE, ...){
# Caluclates a loess fit with the 'loess' function, and makes a plot
#
# Args:
#   x: predictor
#   y: response
#   return.fit: logical
#   ...: Optional arguments to loess
#
# Returns:
#   the loess fit
my.lo <- loess(y ~ x, ...)
x.vals <- seq(from = min(x), to = max(x), length = 100)
my.fit <- predict(object  = my.lo,
newdata = x.vals,
se      = TRUE)
plot(x, y)
lines(x = x.vals, y = my.fit$fit, col = "blue")
lines(x   = x.vals,
y   = my.fit$fit + my.fit$se.fit * qt(p = .975, df = my.fit$df),
col = "blue",
lty = "dashed")
lines(x   = x.vals,
y   = my.fit$fit - my.fit$se.fit * qt(p = .975, df = my.fit$df),
col = "blue",
lty = "dashed")
if (return.fit) {
return(my.lo)
}
}
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.5)
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.25)
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.1)
PlotLoessFit(x = st16$depth, y = st16$sources, span = 0.25, degree = 1)
library(mgcv)
st16.spline <- gam(sources ~ s(depth), data = st16)
plot(st16.spline, se = TRUE)  # note that the plot does not include the intercept
summary(st16.spline)
with(st16, plot(sources ~ depth))
st16.fit <- predict(st16.spline,
newdata = data.frame(depth = depth.vals),
se      = TRUE)
lines(x = depth.vals, y = st16.fit$fit)
## add +/- 2 SE following Zuur; this is only approximate.
## should probably use a critical value from a t-dist with n - edf df, that is, 51 - 9.81 = 41.19 df
lines(x = depth.vals, y = st16.fit$fit + 2 * st16.fit$se.fit, lty = "dashed")
lines(x = depth.vals, y = st16.fit$fit - 2 * st16.fit$se.fit, lty = "dashed")
AIC(st16.spline)
