data = moorhen)
plot(residuals(fm1) ~ moorhen$year)
acf(residuals(fm1))
fm2 <- nlme::gls(log(abundance) ~ rainfall + year,
data = moorhen,
correlation = corAR1(form = ~ year))
summary(fm2)
acf(residuals(fm2, type = "normalized"))
?acf
?ACF.gls
acf(residuals(fm2))
acf(residuals(fm2, resType = "normalized"))
?residuals
?residuals.gls
anova(fm1, fm2)
data("Wheat2")
summary(Wheat2)
with(Wheat2, plot(x = longitude, y = latitude,
pch = as.numeric(Block)))
fm1 <- nlme::gls(yield ~ variety, data = Wheat2)
plot(Variogram(fm1, form = ~ latitude + longitude))
require(plotly)
plot_ly(x = Wheat2$latitude,
y = Wheat2$longitude,
z = resid(fm1),
type = "scatter3d",
mode = "markers",
color = resid(fm1))
fm2 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corSpher(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
print(fm2)
plot(Variogram(fm2, form = ~ latitude + longitude))
plot(Variogram(fm2, form = ~ latitude + longitude, resType = "n"))
fm3 <- nlme::gls(yield ~ variety, data = Wheat2,
correlation = corGaus(c(28, 0.2),
form = ~ latitude + longitude,
nugget = TRUE))  # need to supply starting values
plot(Variogram(fm3, form = ~ latitude + longitude))
plot(Variogram(fm3, form = ~ latitude + longitude, resType = "n"))
anova(fm1, fm2, fm3)
anova(fm1)
anova(fm3)
rdu <- read.table("C:/Users/krgross/Documents/GitHub/bma590-course-notes/data/rdu-temperature.txt", head = T)
# remove NA's, coded as -99
with(rdu, table(temp == -99))
rdu <- subset(rdu, temp > -99)
with(rdu, plot(temp ~ time, type = "l", xlab = "day"))
require(mgcv)
rdu2 <- read.csv("C:/Users/krgross/Downloads/3496928.csv", head = T)
summary(rdu2)
require(lme4)
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/general/ZuurDataMixedModelling/RIKZ.txt", head = T)
rikz$fBeach <- as.factor(rikz$Beach)
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = high.beaches, pch = high.beaches)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
summary(fm3)
fm4 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 + NAP| fBeach), data = rikz)
summary(fm4)
fm5 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach) + (0 + NAP | fBeach),
data = rikz)
summary(fm5)
anova(fm3, fm4, fm5)
pr <- profile(fm3)
lattice::xyplot(pr, absVal = T)
confint(pr)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
rm(list = ls())
legend("topright", leg = high.beaches, pch = high.beaches)
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
legend("topright", leg = high.beaches, pch = high.beaches)
legend("topright", leg = low.beaches, pch = low.beaches)
rm(list = ls())
ant <- read.csv("C:/Users/krgross/Documents/Teaching/bma590/general/data/ant.csv", head = T, stringsAsFactors = T)
ant_s <- subset(ant, genus_species != "Brachyponera chinensis")
with(ant_s, table(genus_species, site))
summary(ant_s)
with(ant_s, table(genus_species, site))
with(ant_s, table(tree_code, site))
with(ant_s, table(genus_species, site))
with(ant_s, table(genus_species, tree_code))
fm1 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
summary(fm1)
fm2 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | genus_species),
data = ant_s)
summary(fm2)
s_data <- with(ant_s, aggregate(ct_max, list(stratum, genus_species), FUN = mean))  # note the rows are sorted alphabetically by species
names(s_data) <- c("stratum", "species", "avg")
s_data$blup <- ranef(fm1)$genus_species[, 1] + coef(summary(fm1))[1, 1] + ifelse(s_data$stratum == "terrestrial", coef(summary(fm1))[2, 1], 0)
with(s_data, stripchart(avg ~ stratum))
with(s_data, stripchart(blup ~ stratum))
with(s_data, plot(blup ~ avg, type = "n"))
with(subset(s_data, stratum == "arboreal"), points(blup ~ avg, pch = "A"))
with(subset(s_data, stratum != "arboreal"), points(blup ~ avg, pch = "T"))
abline(a = 0, b = 1)
pr <- profile(fm1)
lattice::xyplot(pr, absVal = T)
confint(pr)
fm1b <- lmerTest::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
summary(fm1b)
require(lme4)
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/general/ZuurDataMixedModelling/RIKZ.txt", head = T)
rikz$fBeach <- as.factor(rikz$Beach)
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = high.beaches, pch = high.beaches)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
legend("topright", leg = high.beaches, pch = high.beaches)
fm3 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
summary(fm3)
anova(fm3, fm4, fm5)
fm4 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 + NAP| fBeach), data = rikz)
summary(fm4)
fm5 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach) + (0 + NAP | fBeach),
data = rikz)
summary(fm5)
anova(fm3, fm4, fm5)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
legend("topright", leg = low.beaches, pch = low.beaches)
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
legend("topright", leg = high.beaches, pch = high.beaches)
pr <- profile(fm3)
lattice::xyplot(pr, absVal = T)
confint(pr)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
summary(fm3)
rm(list = ls())
ant <- read.csv("C:/Users/krgross/Documents/Teaching/bma590/general/data/ant.csv", head = T, stringsAsFactors = T)
ant_s <- subset(ant, genus_species != "Brachyponera chinensis")
summary(ant_s)
summary(ant_s)
with(ant_s, table(tree_code, site))
with(ant_s, table(genus_species, site))
with(ant_s, table(genus_species, tree_code))
with(ant_s, table(genus_species, tree_code))
fm1 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
summary(fm1)
fm2 <- lme4::lmer(ct_max ~ stratum + (1 | site) + (1 | genus_species),
data = ant_s)
summary(fm2)
s_data <- with(ant_s, aggregate(ct_max, list(stratum, genus_species), FUN = mean))  # note the rows are sorted alphabetically by species
names(s_data) <- c("stratum", "species", "avg")
s_data$blup <- ranef(fm1)$genus_species[, 1] + coef(summary(fm1))[1, 1] + ifelse(s_data$stratum == "terrestrial", coef(summary(fm1))[2, 1], 0)
# with(s_data, stripchart(avg ~ stratum))
with(s_data, stripchart(blup ~ stratum))
# with(s_data, stripchart(avg ~ stratum))
with(s_data, stripchart(blup ~ stratum, pch = 16))
ranef(fm1)
pr <- profile(fm1)
lattice::xyplot(pr, absVal = T)
confint(pr)
fm1b <- lmerTest::lmer(ct_max ~ stratum + (1 | site) + (1 | site:tree) + (1 | genus_species),
data = ant_s)
summary(fm1b)
with(s_data, plot(blup ~ avg, type = "n"))
with(subset(s_data, stratum == "arboreal"), points(blup ~ avg, pch = "A"))
with(subset(s_data, stratum != "arboreal"), points(blup ~ avg, pch = "T"))
abline(a = 0, b = 1)
elephant <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/elephant.txt", head = T)
with(elephant, plot(matings ~ age))
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
(pseudo.R2 <- 1 - 51.012 / 75.372)
new.data <- data.frame(age = seq(from = min(elephant$age),
to   = max(elephant$age),
length = 100))
predict.fm1 <- predict(fm1, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm1$fit, col = "red")
lines(x   = new.data$age,
y   = predict.fm1$fit - 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm1$fit + 1.96 * predict.fm1$se.fit,
col = "red",
lty = "dashed")
fm2 <- glm(matings ~ age,
family = poisson(link = "identity"),
data = elephant)
summary(fm2)
predict.fm2 <- predict(fm2, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm2$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm2$fit - 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm2$fit + 1.96 * predict.fm2$se.fit,
col = "blue",
lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "deviance"),
xlab = "age",
ylab = "Deviance residuals")
abline(h = 0, lty = "dashed")
plot(x = elephant$age,
y = residuals(fm2, type = "pearson"),
xlab = "age",
ylab = "Pearson residuals")
abline(h = 0, lty = "dashed")
fm3 <- glm(matings ~ age, family = quasipoisson(link = "identity"), data = elephant)
summary(fm3)
50.058/39
sqrt(50.058/39)
predict.fm3 <- predict(fm3, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm3$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm3$fit + qt(0.025, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm3$fit + qt(0.975, df = 39) * predict.fm3$se.fit,
col = "blue",
lty = "dashed")
require(MASS)
fm4 <- glm.nb(matings ~ age, link = identity, data = elephant)
summary(fm4)
predict.fm4 <- predict(fm4, newdata = new.data, type = "response", se.fit = TRUE)
with(elephant, plot(matings ~ age))
lines(x = new.data$age, y = predict.fm4$fit, col = "blue")
lines(x   = new.data$age,
y   = predict.fm4$fit + 1.96 * predict.fm4$se.fit,
col = "blue",
lty = "dashed")
lines(x   = new.data$age,
y   = predict.fm4$fit - 1.96 * predict.fm4$se.fit,
col = "blue",
lty = "dashed")
require(rstanarm)
fm4 <- stan_glm(matings ~ age,
family = poisson(link = "identity"),
data   = elephant,
seed   = 1)
print(fm4, digits = 3)
posterior.fm4 <- as.matrix(fm4)
bayesplot::mcmc_areas(posterior.fm4,
pars = c("age"),
prob = 0.95)
prior_summary(fm4)
# relax the priors
fm5 <- stan_glm(matings ~ age,
family = poisson(link = "identity"),
data   = elephant,
prior  = normal(0, 100),
prior_intercept = normal(0, 100),
seed   = 1)
print(fm5, digits = 3)
mcmc.sims <- as.matrix(fm5)
with(elephant, plot(matings ~ age, type = "n"))
sample.sims <- sample(nrow(mcmc.sims), size = 100)
for (i in sample.sims) {
abline(a = mcmc.sims[i, 1], b = mcmc.sims[i, 2], col = "skyblue")
}
abline(a = coef(fm5)['(Intercept)'], b = coef(fm5)['age'], col = "blue", lwd = 2)
with(elephant, points(matings ~ age, pch = 16))
post.predict <- posterior_predict(fm5)
with(elephant, plot(matings ~ age, type = "n"))
points(elephant$age, post.predict[1, ], pch = 16)
with(elephant, plot(matings ~ age, type = "n"))
points(elephant$age, post.predict[2, ], pch = 16)
post.predict.sd <- apply(post.predict, 1, sd)
hist(post.predict.sd, breaks = 20)
abline(v = sd(elephant$matings), col = "red")
pp_check(fm5, plotfun = "stat", stat = "mean",
binwidth = .1)
fm6 <- stan_glm(matings ~ age,
family = quasipoisson(link = "identity"),
data   = elephant,
prior  = normal(0, 100),
prior_intercept = normal(0, 100),
seed   = 1)
fm7 <- stan_glm(matings ~ age,
family = neg_binomial_2(link = "identity"),
data   = elephant,
prior  = normal(0, 100),
prior_intercept = normal(0, 100),
seed   = 1)
(sd_test2 <- pp_check(fm7, plotfun = "stat", stat = "sd", binwidth = .1))
require(R2jags)
elephant.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dpois (mu[j])      # data model:  the likelihood
mu[j] <- exp(eta[j])      # inverse link
eta[j] <- b0 + b1 * x[j]  # linear predictor
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
}
jags.data <- list(y = elephant$matings,
x = elephant$age,
J = nrow(elephant))
jags.params <- c("b0", "b1")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = elephant.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
apply(mcmc.output, 2, mean)
HPDinterval(as.mcmc(mcmc.output), prob = 0.95)
plot(matings ~ age, data = elephant, type = "n")
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
b0 <- mcmc.output$b0[i]
b1 <- mcmc.output$b1[i]
my.fit <- function(x) exp(b0 + b1 * x)
curve(my.fit,
from = min(elephant$age),
to   = max(elephant$age),
col  = "deepskyblue",
lwd  = 1,
add  = TRUE)
}
with(elephant, points(matings ~ age, pch = 16))
post.means <- apply(mcmc.output, 2, mean)
my.fit <- function(x) exp(post.means['b0'] + post.means['b1'] * x)
curve(my.fit,
from = min(elephant$age),
to   = max(elephant$age),
col  = "blue",
lwd  = 2,
add  = TRUE)
elephant.model.2 <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dpois (mu[j])      # data model:  the likelihood
mu[j] <- exp(eta[j])      # inverse link
eta[j] ~ dnorm(b0 + b1 * x[j], tau_eps)  # linear predictor, includes observation-level random effect
}
b0 ~ dnorm (0.0, 1E-6)       # prior for intercept
b1 ~ dnorm (0.0, 1E-6)       # prior for slope
tau_eps ~ dgamma (0.01, 0.01)
sd_eps <- pow(tau_eps, -1/2)
}
jags.data <- list(y = elephant$matings,
x = elephant$age,
J = nrow(elephant))
jags.params <- c("b0", "b1", "sd_eps")
jags.inits <- function(){
list("b0" = rnorm(1), "b1" = rnorm(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit2 <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = elephant.model.2,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
mcmc.output <- as.data.frame(jagsfit2$BUGSoutput$sims.list)
apply(mcmc.output, 2, mean)
HPDinterval(as.mcmc(mcmc.output), prob = 0.95)
plot(matings ~ age, data = elephant, type = "n")
subset.samples <- sample(nrow(mcmc.output), size = 100)
for(i in subset.samples) {
b0 <- mcmc.output$b0[i]
b1 <- mcmc.output$b1[i]
my.fit <- function(x) exp(b0 + b1 * x)
curve(my.fit,
from = min(elephant$age),
to   = max(elephant$age),
col  = "deepskyblue",
lwd  = 1,
add  = TRUE)
}
with(elephant, points(matings ~ age, pch = 16))
post.means <- apply(mcmc.output, 2, mean)
my.fit <- function(x) exp(post.means['b0'] + post.means['b1'] * x)
curve(my.fit,
from = min(elephant$age),
to   = max(elephant$age),
col  = "blue",
lwd  = 2,
add  = TRUE)
elephant <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/elephant.txt", head = T)
with(elephant, plot(matings ~ age))
with(elephant, plot(matings ~ age, pch = 16))
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
fm1a <- glm(matings ~ 1,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1a)
anova(fm0, fm1)
fm0 <- glm(matings ~ 1,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm0)
anova(fm0, fm1)
anova(fm0, fm1, test = "Chisq")
summary(fm1)
fm1a <- glm(matings ~ age + I(age^2),
family = poisson(link = "log"),
data   = elephant)  # log link is the default
anova(fm0, fm1, fm1a)
summary(fm2)
anova(fm0, fm1, fm1a, test = "Chisq")
summary(fm2)
summary(fm1a)
?glm
fm0 <- lm(matings ~ age, family = gaussian, data = elephant)
fm0 <- glm(matings ~ age, family = gaussian, data = elephant)
summary(fm0)
fm1 <- lm(matings ~ age, data = elephant)
summary(fm1)
133.28 / 39
sqrt(133.28 / 39)
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", bookdown::gitbook)
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", bookdown::gitbook)
bookdown::render_book("index.Rmd", bookdown::gitbook)
bookdown::preview_chapter("07-GeneralizedLinearModels.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
