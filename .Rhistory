# would have been better to code the beaches as b1, b2, ...
rikz$fBeach <- as.factor(rikz$Beach)
#######################
# Model 1: random intercept
#######################
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# add a line for beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
#######################
# Model 2: random slope and intercept (possibly correlated)
#######################
fm2 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 + NAP | fBeach), data = rikz)
summary(fm2)
ranef(fm2)
# make a plot
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
# add a line for the average relationship across all beaches
a <- coef(summary(fm2))[1, 1]
b <- coef(summary(fm2))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# add a line for beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm2)$fBeach
abline(a = a + c.mode[1, 1], b = b + c.mode[1, 2], col = "red", lty = "dotted")
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope")
anova(fm1, fm2)  # could compare REML fits by fitting both models with nlme::lme
anova(fm1, fm2)  # could compare REML fits by fitting both models with nlme::lme
#######################
# Model 2a: random slope and intercept (independent)
#######################
fm2a <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach) + (0 + NAP | fBeach), data = rikz)
anova(fm1, fm2a, fm2)
require(lme4)
require(lmerTest)
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/ZuurDataMixedModelling/RIKZ.txt", head = T)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
# change the Beach variable to a factor
# would have been better to code the beaches as b1, b2, ...
rikz$fBeach <- as.factor(rikz$Beach)
#######################
# Model 1: random intercept
#######################
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# add a line for beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
#######################
# Model 2: random slope and intercept (possibly correlated)
#######################
fm2 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 + NAP | fBeach), data = rikz)
summary(fm2)
ranef(fm2)
# make a plot
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
# add a line for the average relationship across all beaches
a <- coef(summary(fm2))[1, 1]
b <- coef(summary(fm2))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# add a line for beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm2)$fBeach
abline(a = a + c.mode[1, 1], b = b + c.mode[1, 2], col = "red", lty = "dotted")
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope")
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = beach)
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = 1:9)
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = "1:9")
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = 1:9)
# plot the conditional modes of the random effects
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = as.character(1:9))
anova(fm1, fm2)  # could compare REML fits by fitting both models with nlme::lme
#######################
# Model 2a: random slope and intercept (independent)
#######################
fm2a <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach) + (0 + NAP | fBeach), data = rikz)
anova(fm1, fm2a, fm2)
# create an 'exposure' factor, with two levels: low and high
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
#######################
# Model 3: random intercept, with effect of exposure
#######################
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + fExp + NAP:fExp + (1 | fBeach), data = rikz)
# equivalently
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP * fExp + (1 | fBeach), data = rikz)
summary(fm3)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
# Repeat for high exposure beaches
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
fm4 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + fExp + (1 | fBeach), data = rikz)
a0 <- coef(summary(fm4))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm4))[2, 1]  # common slope for all beaches
a1 <- coef(summary(fm4))[3, 1]  # difference in marginal intercepts for high vs low
c.mode <- ranef(fm4)$fBeach
# this code is ugly, but oh well
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
# Repeat for high exposure beaches
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0, col = "blue", lty = "dotted")
}
# we want a model where the variance of the random beach effects differs between low vs. high exposure beaches.
# how do we do that??
fm4 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + fExp + (1 | fBeach), data = rikz)
a0 <- coef(summary(fm4))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm4))[2, 1]  # common slope for all beaches
a1 <- coef(summary(fm4))[3, 1]  # difference in marginal intercepts for high vs low
c.mode <- ranef(fm4)$fBeach
# this code is ugly, but oh well
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
# Repeat for high exposure beaches
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0, col = "blue", lty = "dotted")
}
# we want a model where the variance of the random beach effects differs between low vs. high exposure beaches.
# how do we do that??
#######################
# Model 1: random intercept
#######################
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# highlight beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
# make a plot with a line for each beach
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = a + c.mode[1, i], b = b, col = "red", lty = "dotted")
}
#######################
# Model 1: random intercept
#######################
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
# highlight beach 1
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
# make a plot with a line for each beach
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = a + c.mode[i, 1], b = b, col = "red", lty = "dotted")
}
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm0 <- lm(Yield ~ 1, data = Dyestuff)          # model with common mean
fm1 <- lm(Yield ~ Batch - 1, data = Dyestuff)  # mean varies by group
anova(fm0, fm1)  # usual F-test for differences among group means
summary(fm1)  # eliminating the intercept gives sample means for each group
require(nlme)
fm2 <- gls(Yield ~ 1, data = Dyestuff,
correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm2)
fm3 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm3)
fixef(fm3)
(batch.conditional.modes <- (fixef(fm3) + ranef(fm3)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
fm3ML <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff, REML = FALSE)
summary(fm3ML)
pr <- profile(fm3ML)
lattice::xyplot(pr)
lattice::xyplot(pr, absVal = TRUE)
confint(pr, level = .95)
confint(pr, level = .99)
lattice::splom(pr)
require(lmerTest)
fm4 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm4)
require(R2jags)
dyestuff.model <- function() {
## likelihood
for (j in 1:J) {
y[j]    ~ dnorm(B[batch[j]], tau_eps)  # data distribution
}
## latent variables
for (b in 1:6){
B[b] ~ dnorm(mu, tauB)
}
mu ~ dnorm (0.0, 1E-6)  # prior for the overall mean
tau_eps ~ dgamma (0.01, 0.01)
tauB    ~ dgamma (0.01, 0.01)
sd_eps <- pow(tau_eps, -1/2)
sdB    <- pow(tauB, -1/2)
}
jags.data <- list(y     = Dyestuff$Yield,
batch = as.numeric(Dyestuff$Batch),
J     = nrow(Dyestuff))
jags.params <- c("mu", "sd_eps", "sdB", "B[1]", "B[2]")
jags.inits <- function(){
list("mu" = rnorm(1, .01), "tauB" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = dyestuff.model,
n.chains           = 3,
n.iter             = 1e5)
print(jagsfit)
traceplot(jagsfit)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
data(Dyestuff2)
summary(Dyestuff2)
with(Dyestuff2, stripchart(Yield ~ Batch, pch = 16))
fm5 <- gls(Yield ~ 1, data = Dyestuff2, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm5)
fm6 <- lme4::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
summary(fm6)
rm(list = ls())
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/ZuurDataMixedModelling/RIKZ.txt", head = T)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
rikz$fBeach <- as.factor(rikz$Beach)
fm1 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach), data = rikz)
summary(fm1)
# extract the conditional modes for the beach random effects
ranef(fm1)
# replot the data and add a line for the average relationship across all beaches
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm1)$fBeach
abline(a = a + c.mode[1, 1], b = b, col = "red", lty = "dotted")
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm1))[1, 1]
b <- coef(summary(fm1))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
for(i in 1:9){
abline(a = a + c.mode[i, 1], b = b, col = "red", lty = "dotted")
}
fm2 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 + NAP | fBeach), data = rikz)
summary(fm2)
ranef(fm2)
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))
legend("topright", leg = 1:9, pch = 1:9)
a <- coef(summary(fm2))[1, 1]
b <- coef(summary(fm2))[2, 1]
abline(a = a, b = b, col = "red", lwd = 2)
with(subset(rikz, Beach == 1), points(x = NAP, y = sqrt(Richness), col = "red", pch = 16))
c.mode <- ranef(fm2)$fBeach
abline(a = a + c.mode[1, 1], b = b + c.mode[1, 2], col = "red", lty = "dotted")
plot(x = a + c.mode[, 1], y = b + c.mode[, 2], xlab = "intercept", ylab = "slope", pch = as.character(1:9))
anova(fm1, fm2)  # could compare REML fits by fitting both models with nlme::lme
fm2a <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + (1 | fBeach) + (0 + NAP | fBeach), data = rikz)
anova(fm1, fm2a, fm2)
with(rikz, table(fBeach, Exposure))
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
summary(rikz)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP + fExp + NAP:fExp + (1 | fBeach), data = rikz)
fm3 <- lmerTest::lmer(sqrt(Richness) ~ 1 + NAP * fExp + (1 | fBeach), data = rikz)
summary(fm3)
a0 <- coef(summary(fm3))[1, 1]  # marginal intercept for low-exposure beaches
b0 <- coef(summary(fm3))[2, 1]  # marginal slope for low-exposure beaches
a1 <- coef(summary(fm3))[3, 1]  # difference in marginal intercepts for high vs low
b1 <- coef(summary(fm3))[4, 1]  # difference in marginal slopes for high vs low
c.mode <- ranef(fm3)$fBeach
low.beaches <- c(1, 2, 5, 8, 9)
high.beaches <- c(3, 4, 6, 7)
par(mfrow = c(1, 2))  # split the plot region
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 8 or 10"))  # set up the axes
with(subset(rikz, fExp == "10"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0, b = b0, col = "red", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(low.beaches)) {
abline(a = a0 + c.mode[low.beaches[i], 1], b = b0, col = "red", lty = "dotted")
}
with(rikz, plot(sqrt(Richness) ~ NAP,
type     = "n",
main     = "Exposure = 11"))  # set up the axes
with(subset(rikz, fExp == "11"), points(sqrt(Richness) ~ NAP, pch = Beach))  # plot points for low exposure beaches
abline(a = a0 + a1, b = b0 + b1, col = "blue", lwd = 2)  # add the average line for low-exposure beaches
for (i in 1:length(high.beaches)) {
abline(a = a0 + a1 + c.mode[high.beaches[i], 1], b = b0 + b1, col = "blue", lty = "dotted")
}
require(rstanarm)
stan_fm1 <- stan_lmer(formula = Yield ~ 1 + (1 | Batch),
data = Dyestuff,
seed = 1)
prior_summary(stan_fm1)
print(stan_fm1, digits = 2)
summary(stan_fm1,
# pars = c("(Intercept)", "sigma", "Sigma[school:(Intercept),(Intercept)]"),
probs = c(0.025, 0.975),
digits = 2)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm0 <- lm(Yield ~ 1, data = Dyestuff)          # model with common mean
fm1 <- lm(Yield ~ Batch - 1, data = Dyestuff)  # mean varies by group
anova(fm0, fm1)  # usual F-test for differences among group means
summary(fm1)  # eliminating the intercept gives sample means for each group
require(nlme)
fm2 <- gls(Yield ~ 1, data = Dyestuff,
correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm2)
fm3 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm3)
fixef(fm3)
(batch.conditional.modes <- (fixef(fm3) + ranef(fm3)$Batch$`(Intercept)`))
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/ZuurDataMixedModelling/RIKZ.txt", head = T)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
rikz$fBeach <- as.factor(rikz$Beach)
# create an 'exposure' factor, with two levels: low and high
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
# model with exposure class and NAP as predictors but no random effect for the beach
fm0 <- lm(sqrt(Richness) ~ fExp * NAP, data = rikz)
summary(fm0)
model.matrix(fm0)
require(lme4)
require(lmerTest)
?getME
getME(fm3)
fm3 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
getME(fm3)
getME(fm3, name = "X")
getME(fm3, name = "Z")
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
model.matrix(cricket.slr)
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
require(lme4)
require(lmerTest)
cricket <- read.table("C:/Users/krgross/Documents/Teaching/bma590/bma590-fall21/data/cricket.txt", header = TRUE)
cricket.slr <- lm(chirps ~ temperature, data = cricket)
model.matrix(cricket.slr)
rm(list = ls())
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/ZuurDataMixedModelling/RIKZ.txt", head = T)
with(rikz, plot(Richness ~ NAP, pch = Beach))  # raw response; note the non-constant variance
with(rikz, plot(sqrt(Richness) ~ NAP, pch = Beach))  # transformation stabilizes the variance
legend("topright", leg = 1:9, pch = 1:9)
rikz$fBeach <- as.factor(rikz$Beach)
rikz$fExp <- rikz$Exposure  # make a new variable so that we can leave the original alone
rikz$fExp[rikz$Exposure == 8] <- 10  # assign a value of 10 to the lone beach with exposure = 8
rikz$fExp <- as.factor(rikz$fExp)  # make the new variable into a factor
fm3 <- lme4::lmer(sqrt(Richness) ~ fExp * NAP + (1 | fBeach), data = rikz)
getME(fm3, name = "X")
getME(fm3, name = "Z")
fm0 <- lm(sqrt(Richness) ~ fExp * NAP, data = rikz)
summary(fm0)
model.matrix(fm0)
rm(list = ls())
library(MASS)
data(oats)
summary(oats)
fm1 <- lmerTest::lmer(Y ~ V * N + (1 | B) + (1 | B : V), data = oats)
fm1a <- lmerTest::lmer(Y ~ V * N + (1 | B / V), data = oats)
anova(fm1)
contrasts(oats$N) <- contr.poly(n = 4)
fm1 <- lmerTest::lmer(Y ~ V * N +  (1 | B) + (1 | B : V), data = oats)
summary(fm1)
with(oats, plot(Y ~ N))
rm(list = ls())
golf <- read.table("data/golf.txt", head = T)
fm1 <- lmerTest::lmer(score ~ 1 + (1 | player) + (1 | round), data = golf)
summary(fm1)  # comparison of the std devs of the random effects is interesting
player.modes <- ranef(fm1)$player
head(player.modes)
(round.modes <- ranef(fm1)$round)
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes[, 1],
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", ylab = "rounds played",
xlab = "conditional mode", pch = 1))
