var(myxo$titer)
var.usual <- ss / (n - 1)
var(myxo$titer)
var.usual <- ss / (n - 1)
var.usual
var(myxo$titer)
?data.fit
?outer
?contour
source('~/.active-rstudio-document')
summary(ll.vals)
source('~/.active-rstudio-document')
contour(x = m.vals, y = v.vals, z = ll.vals)
source('~/.active-rstudio-document')
contour(x = m.vals, y = v.vals, z = ll.vals)
myxo.mle <- optim(par = c(7, 1),  # starting values, just a ballpark guess
fn  = myxo.neg.ll)
myxo.neg.ll <- function(pars){
m <- pars[1]
v <- pars[2]
ll.vals <- dnorm(myxo$titer, mean = m, sd = sqrt(v), log = TRUE)
ll <- sum(ll.vals)
return(-ll)
}
myxo.mle <- optim(par = c(7, 1),  # starting values, just a ballpark guess
fn  = myxo.neg.ll)
myxo.mle
source('~/.active-rstudio-document')
contour(x = m.vals, y = v.vals, z = ll.vals)
contour(x = m.vals, y = v.vals, z = ll.vals, nlevels = 100)
m.vals <- seq(from = 1, to = 10, by = 0.1)
v.vals <- seq(from = 0.5, to = 2, by = 0.1)
ll.vals <- matrix(nrow = length(m.vals), ncol = length(v.vals))
for (i.m in 1:length(m.vals)) {
for(i.v in 1:length(v.vals)) {
ll.vals[i.m, i.v] <- myxo.ll(m = m.vals[i.m], v = v.vals[i.v])
}
}
contour(x = m.vals, y = v.vals, z = ll.vals, nlevels = 100,
xlab = "mean", ylab = "variance")
# show the MLE
points(x = myxo.mle$par[1], y = myxo.mle$par[2])
source('~/Teaching/bma590/r/class03.R')
source('~/Teaching/bma590/r/class03.R')
.004 / .296
?rpois
getwd*(
)
getwd()
knitr::opts_chunk$set(echo = TRUE)
moth <- data.frame("moth.txt", head = T)
moth
moth <- data.frame("C:/Users/krgross/Documents/Teaching/bma590/homework/hwk1/moth.txt", head = T)
moth
moth <- read.table("C:/Users/krgross/Documents/Teaching/bma590/homework/hwk1/moth.txt", head = T)
summary(moth)
?dbinom
moth <- read.table("C:/Users/krgross/Documents/Teaching/bma590/homework/hwk1/moth.txt", head = T)
# write the negative log likelihood function
moth.neg.ll <- function(params){
a_l <- params[1]
b_l <- params[2]
a_d <- params[3]
b_d <- params[4]
light.moth <- subset(moth, morph == "light")
dark.moth <- subset(moth, morph == "dark")
light.prob <- exp(a_l + b_l * light.moth$distance) / (1 + exp(a_l + b_l * light.moth$distance))
dark.prob <-exp(a_d + b_d * dark.moth$distance) / (1 + exp(a_d + b_d * dark.moth$distance))
ll.vals.light <- dbinom(x    = light.moth$removed,
size = light.moth$placed,
prob = light.prob,
log  = TRUE)
ll.vals.dark <-  dbinom(x    = dark.moth$removed,
size = dark.moth$placed,
prob = dark.prob,
log  = TRUE)
neg.ll <- -1 * (sum(ll.vals.light) + sum(ll.vals.dark))
return(neg.ll)
}
# obtain the MLEs
moth.mle <- optim(par = c(0, -1, 0, 1),
fn  = moth.neg.ll)
moth.neg.ll(c(0, -1, 0, 1))
debug(moth.neg.ll)
moth.neg.ll(c(0, -1, 0, 1))
light.prob
dark.prob
moth.neg.ll(c(0, -.1, 0, .1))
moth <- read.table("C:/Users/krgross/Documents/Teaching/bma590/homework/hwk1/moth.txt", head = T)
# write the negative log likelihood function
moth.neg.ll <- function(params){
a_l <- params[1]
b_l <- params[2]
a_d <- params[3]
b_d <- params[4]
light.moth <- subset(moth, morph == "light")
dark.moth <- subset(moth, morph == "dark")
light.prob <- exp(a_l + b_l * light.moth$distance) / (1 + exp(a_l + b_l * light.moth$distance))
dark.prob <-exp(a_d + b_d * dark.moth$distance) / (1 + exp(a_d + b_d * dark.moth$distance))
ll.vals.light <- dbinom(x    = light.moth$removed,
size = light.moth$placed,
prob = light.prob,
log  = TRUE)
ll.vals.dark <-  dbinom(x    = dark.moth$removed,
size = dark.moth$placed,
prob = dark.prob,
log  = TRUE)
neg.ll <- -1 * (sum(ll.vals.light) + sum(ll.vals.dark))
return(neg.ll)
}
# obtain the MLEs
moth.mle <- optim(par = c(0, -0.1, 0, 0.1),
fn  = moth.neg.ll)
moth.mle
moth.neg.ll.reduced <- function(parms){
a <- parms[1]
b <- parms[2]
ans <- moth.neg.ll(c(a, b, a, b))
return(ans)
}
moth.reduced.mle <- optim(par = c(0, 0),
fn  = moth.neg.ll.reduced)
moth.reduced.mle
moth.mle
moth.neg.ll.reduced <- function(parms){
a <- parms[1]
b <- parms[2]
ans <- moth.neg.ll(c(a, b, a, b))
return(ans)
}
moth.mle.reduced <- optim(par = c(0, 0),
fn  = moth.neg.ll.reduced)
moth.mle.reduced
?pchisq
moth.neg.ll.reduced <- function(parms){
a <- parms[1]
b <- parms[2]
ans <- moth.neg.ll(c(a, b, a, b))
return(ans)
}
moth.mle.reduced <- optim(par = c(0, 0),
fn  = moth.neg.ll.reduced)
# calculate the test statistic for the likelihood ratio test
lrt.statistic <- 2 * (moth.mle.reduced$value - moth.mle$value)
lrt.statistic
# calculate the p-value
pchisq(q = lrt.statistic, df = 2, lower.tail = FALSE)
aic.full <- 2 * moth.mle$value + 8
aic.reduced <- 2 * moth.mle.reduced$value + 4
aic.full <- 2 * moth.mle$value + 8
aic.full
aic.reduced <- 2 * moth.mle.reduced$value + 4
aic.reduced
aicc.full <- aic.full + (2 * 4 * 5) / (14 - 4 - 1)
aicc.full
aicc.reduced <- aic.reduced + (2 * 2 * 3) / (14 - 2 - 1)
aicc.reduced
?legend
library(lmer)
library(lme4)
library(lmerTest)
fm2 <- lmerTest::lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff2)
ranef(fm2)
Elston2001_tickdata <- read.delim("~/Teaching/bma590/www/data/Elston2001_tickdata.txt")
View(Elston2001_tickdata)
Elston2001_tickdata <- read.delim("~/Teaching/bma590/www/data/Elston2001_tickdata.txt")
View(Elston2001_tickdata)
ticks <- Elston2001_tickdata
ticks$brood <- as.factor(ticks$brood)
ticks$location <- as.factor(ticks$location)
summary(ticks)
ticks$year <- as.factor(ticks$year)
summary(ticks)
rm(Elston2001_tickdata)
ticks$height.ctr <- with(ticks, height - mean(height))
summary(ticks)
with(ticks, plot(ticks ~ height.ctr))
with(ticks, plot(sqrt(ticks) ~ height.ctr))
fm1 <- lmerTest::lmer(log(ticks + 1) ~ height * year + (1 | location / brood), data = ticks)
summary(fm1)
rm(fm2)
fm2 <- lmerTest::lmer(log(ticks + 1) ~ height * year + (1 | location) + (1 | brood), data = ticks)
summary(fm2)
fm2 <- lmerTest::lmer(log(ticks + 1) ~ height + year + (1 | location / brood), data = ticks)
anova(fm1, fm2)
anova(fm1)
summary(ticks)
tick <- read.table("C:/Users/krgross/Documents/Teaching/bma590/www/data/tick.txt", head = T)
tick$year     <- as.factor(tick$year)
tick$brood    <- as.factor(tick$brood)
tick$location <- as.factor(tick$location)
summary(ticks)
tick$height.ctr <- with(tick, height - mean(height))
summary(tick)
tick$height.ctr <- with(tick, height - mean(height))
par(mfrow = c(1, 3))
with(tick, plot(log(count + 1) ~ height.ctr, type = "n", main = "1995"))
with(subset(tick, year == "95"), points(log(count + 1) ~ height.ctr))
with(tick, plot(log(count + 1) ~ height.ctr, type = "n", main = "1996"))
with(subset(tick, year == "96"), points(log(count + 1) ~ height.ctr))
with(tick, plot(log(count + 1) ~ height.ctr, type = "n", main = "1997"))
with(subset(tick, year == "97"), points(log(count + 1) ~ height.ctr))
with(tick, table(location, year))
# test for the significance of the variance term for brood
fm2 <- lmerTest::lmer(log(count + 1) ~ height * year + (1 | location), data = ticks)
# test for the significance of the variance term for brood
fm2 <- lmerTest::lmer(log(count + 1) ~ height * year + (1 | location), data = tick)
anova(fm1, fm2)
fm1 <- lmerTest::lmer(log(count + 1) ~ height * year + (1 | location / brood), data = ticks)
fm1 <- lmerTest::lmer(log(count + 1) ~ height * year + (1 | location / brood), data = tick)
anova(fm1, fm2)
library(MASS)
data("Sitka")
summary(Sitka)
1 - 51.012 / 75.372
knitr::opts_chunk$set(echo = TRUE)
rikz <- read.table("C:/Users/krgross/Documents/Teaching/bma590/ZuurDataMixedModelling/RIKZ.txt", head = T)
# use only low-exposure beaches
rikz <- droplevels(subset(rikz, Exposure < 11))
## The low-exposure beaches are numbered 1, 2, 5, 8, 9
## For compatibility with JAGS, we want the beaches to be numbered
## 1, 2, 3, 4, 5.  To re-do the numbers, we will use a trick of
## first converting beach to a factor, and then re-converting it to
## a numeric vector.
rikz$Beach <- as.numeric(as.factor(rikz$Beach))
rikz$fBeach  <- as.factor(rikz$Beach)
rikz$fSample <- as.factor(rikz$Sample)
# for comparison, fit a GLMM with an observation-level random effect
require(lme4)
fm1 <- glmer(Richness ~ 1 + NAP + (1 + NAP | fBeach) + (1 | fSample),
family = poisson,
data = rikz)
summary(fm1)
ranef(fm1)  # conditional modes
require(R2jags)
rikz.model <- function() {
## likelihood
for (j in 1:J) {
eta[j] <- a + A[beach[j]] + (b + B[beach[j]]) * x[j] + eps[j]  # linear predictor
y[j] ~ dpois(exp(eta[j]))  # data distribution
}
## latent random variables
for (j in 1:5){
A[j] ~ dnorm(0, tauA)
B[j] ~ dnorm(0, tauB)
}
for (j in 1:J) {
eps[j]  ~ dnorm(0, tau_eps)
}
## prior
a ~ dnorm (0.0, 1E-6)
b ~ dnorm (0.0, 1E-6)
tauA ~ dgamma (0.01, 0.01)
tauB ~ dgamma (0.01, 0.01)
tau_eps ~ dgamma(0.01, 0.01)
sdA <- pow(tauA, -1/2)
sdB <- pow(tauB, -1/2)
sd_eps <- pow(tau_eps, -1/2)
}
jags.data <- list(y     = rikz$Richness,
x     = rikz$NAP,
beach = rikz$Beach,
J     = nrow(rikz))
jags.params <- c("a", "b", "sdA", "sdB", "sd_eps", "A[1]", "A[2]", "B[1]", "B[2]")
jags.inits <- function(){
list("a" = rnorm(1), "b" = rnorm(1),
"tauA" = runif(1), "tauB" = runif(1), "tau_eps" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = rikz.model,
n.chains           = 3,
n.iter             = 2e5)
print(jagsfit)
# traceplot(jagsfit)  (traceplots omitted here to avoid excess output)
require(lattice)
jagsfit.mcmc <- as.mcmc(jagsfit)
densityplot(jagsfit.mcmc)
# inference: what is the posterior probability
# of a negative association between NAP and richness?
with(jagsfit$BUGSoutput$sims.list, table(b < 0))
## make a plot of the fit
with(rikz, plot(Richness ~ NAP, type = "n"))
for (i in 1:5) {
with(subset(rikz, Beach == i),
points(Richness ~ NAP, col = i + 1, pch = 16, cex = 2))
}
NAP.vals <- with(rikz, seq(from   = min(NAP),
to     = max(NAP),
length = 100))
lines(x = NAP.vals,
y = exp(2.058 - 0.665 * NAP.vals),
lwd = 2)
lines(x = NAP.vals,
y = exp(2.220 - 0.221 * NAP.vals),
lwd = 2,
lty = "dashed",
col = 2)
lines(x = NAP.vals,
y = exp(2.427 - 0.372 * NAP.vals),
lwd = 2,
lty = "dashed",
col = 3)
legend("topright",
leg = c("mean", "beach 1", "beach 2"),
col = 1:3,
lty = c("solid", "dashed", "dashed"),
pch = c(NA, 16, 16),
cex = 2,
lwd = 2)
rikz.model.alternate <- function() {
## likelihood
for (j in 1:J) {
eta[j] <- A[beach[j]] + B[beach[j]] * x[j] + eps[j]  # linear predictor
y[j]    ~ dpois(exp(eta[j]))  # data distribution
}
## latent variables
for (j in 1:5){
A[j] ~ dnorm(a, tauA)  # note the difference here
B[j] ~ dnorm(b, tauB)
eps[j]  ~ dnorm(0, tau_eps)
}
a ~ dnorm (0.0, 1E-6)
b ~ dnorm (0.0, 1E-6)
tauA ~ dgamma (0.01, 0.01)
tauB ~ dgamma (0.01, 0.01)
tau_eps ~ dgamma(0.01, 0.01)
sdA <- pow(tauA, -1/2)
sdB <- pow(tauB, -1/2)
sd_eps <- pow(tau_eps, -1/2)
}
## the rest would be the same.
## Three-parameter logistic model fit
## to the orange tree data
## From a frequentist perspective, this would
## be a non-linear mixed effects model.
## complicated, but doable; see Pinheiro & Bates (2000), Ch. 6-8
data(Orange)
with(Orange, plot(circumference ~ age, type = "n"))
for (i in 1:5) {
points(circumference ~ age,
data = subset(Orange, Tree == i),
pch = 16,
col = i,
cex = 2)
lines(circumference ~ age,
data = subset(Orange, Tree == i),
col = i,
lwd = 2)
}
orange.model <- function() {
for (j in 1:J) {
y.hat[j] <- th1[tree[j]] / (1 + exp((th2[tree[j]] - x[j]) / th3[tree[j]]))
y[j] ~ dnorm (y.hat[j], tau.eps)
}
for (j in 1:5){
th1[j] ~ dnorm(mu1, tau1)
th2[j] ~ dnorm(mu2, tau2)
th3[j] ~ dnorm(mu3, tau3)
}
mu1 ~ dnorm (0.0, 1E-6)
mu2 ~ dnorm (0.0, 1E-6)
mu3 ~ dnorm (0.0, 1E-6)
tau1 ~ dgamma (0.01, 0.01)
tau2 ~ dgamma (0.01, 0.01)
tau3 ~ dgamma (0.01, 0.01)
tau.eps ~ dgamma(0.01, 0.01)
sd1 <- pow(tau1, -1/2)
sd2 <- pow(tau2, -1/2)
sd3 <- pow(tau3, -1/2)
sd.eps <- pow(tau.eps, -1/2)
}
jags.data <- list(y    = Orange$circumference,
x    = Orange$age,
tree = Orange$Tree,
J    = nrow(Orange))
jags.params <- c("mu1", "mu2", "mu3", "sd1", "sd2", "sd3", "sd.eps", "th1[1]", "th2[1]", "th3[1]")
jags.inits <- function(){
list("mu1" = rnorm(1), "mu2" = rnorm(1), "mu3" = rnorm(1),
"tau1" = runif(1), "tau2" = runif(1), "tau3" = runif(1),
"tau.eps" = runif(1))
}
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = orange.model,
n.chains           = 3,
n.iter             = 2e5)
library(ggplot2)
library(dplyr)
smaller <- diamonds %>%
filter(carat <= 2.5)
a <- 1
(a + 1)
?mean
?median
?plot
require(nlme)
?varPower
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
knitr::opts_chunk$set(echo = TRUE)
require(lme4)
data(Dyestuff)
summary(Dyestuff)
with(Dyestuff, stripchart(Yield ~ Batch, pch = 16))
fm0 <- lm(Yield ~ 1, data = Dyestuff)          # model with common mean
fm1 <- lm(Yield ~ Batch - 1, data = Dyestuff)  # mean varies by group
anova(fm0, fm1)  # usual F-test for differences among group means
summary(fm1)  # eliminating the intercept gives sample means for each group
require(nlme)
fm2 <- gls(Yield ~ 1, data = Dyestuff, correlation = corCompSymm(form = ~ 1 | Batch))
summary(fm2)
fm3 <- lmer(Yield ~ 1 + (1 | Batch), data = Dyestuff)
summary(fm3)
var.B   <- 1764
var.eps <- 2451
var.B / (var.B + var.eps)
ranef(fm3)
(batch.conditional.modes <- (fixef(fm3) + ranef(fm3)$Batch)$`(Intercept)`)
(batch.means <- with(Dyestuff, tapply(Yield, Batch, mean)))
cbind(batch.means, batch.conditional.modes)
plot(x    = batch.means,
y    = batch.conditional.modes,
xlim = range(batch.means),
ylim = range(batch.means),
xlab = "sample means",
ylab = "conditional modes",
pch  = LETTERS[1:6])
abline(a = 0, b = 1)
library(MASS)
?oats
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(MASS)
require(lme4)
require(lmerTest)
data(oats)
summary(oats)
fm1 <- lmerTest::lmer(Y ~ V * N + (1 | B) + (1 | B : V), data = oats)
# alternatively
fm1a <- lmerTest::lmer(Y ~ V * N + (1 | B / V), data = oats)
summary(fm1)
anova(fm1)
rm(list = ls())
library(MASS)
require(lme4)
require(lmerTest)
data(oats)
summary(oats)
fm1 <- lmerTest::lmer(Y ~ V * N + (1 | B) + (1 | B : V), data = oats)
# alternatively
fm1a <- lmerTest::lmer(Y ~ V * N + (1 | B / V), data = oats)
summary(fm1)
anova(fm1)
contrasts(oats$N) <- contr.poly(n = 4)
fm1 <- lmerTest::lmer(Y ~ V * N +  (1 | B) + (1 | B : V), data = oats)
summary(fm1)
with(oats, plot(Y ~ N))
rm(list = ls())
golf <- read.table("data/golf.txt", head = T)
fm1 <- lmerTest::lmer(score ~ 1 + (1 | player) + (1 | round), data = golf)
summary(fm1)  # comparison of the std devs of the random effects is interesting
ranef(fm1)
player.modes <- ranef(fm1)$player
round.modes <- ranef(fm1)$round
player.modes <- ranef(fm1)$player
head(player.modes)
(round.modes <- ranef(fm1)$round)
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes,
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", pch = 1))
head(player.stats)
player.stats <- data.frame(mode = player.modes,
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", pch = 1))
player.stats
head(player.stats)
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes,
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", pch = 1))
head(player.stats)
player.stats <- data.frame(name = row.names(player.modes),
mode = as.vector(player.modes),
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", pch = 1))
head(player.stats)
str(player.modes)
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes[, 1],
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", pch = 1))
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes[, 1],
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", ylab = "rounds played", pch = 1))
player.stats <- data.frame(name = row.names(player.modes),
mode = player.modes[, 1],
rds  = with(golf, as.numeric(table(player))))
with(player.stats, stripchart(mode ~ as.factor(rds), method = "jitter", ylab = "rounds played",
xlab = "conditional mode", pch = 1))
?knitr::include_graphics
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
getwd()
setwd("C:/Users/krgross/Documents/GitHub/bma590-course-notes/")
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
getwd()
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
