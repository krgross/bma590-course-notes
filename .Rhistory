for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
points(x = dark$distance, y = dark$prop.removed, pch = 16)
with(mcmc.output, HPDinterval(b.1 - b.2))
moth.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j]   ~ dbin(p[j], n[j])      # data distribution
p[j]   <- ilogit(eta[j])      # inverse link
eta[j] ~ dnorm(a[morph[j]] + b[morph[j]] * dist[j] + L[loc[j]], tau_eps)  # linear predictor,
}
for (j in 1:7){  # random effects for location
L[j] ~ dnorm(0, tau_L)
}
a[1] ~ dnorm (0.0, 1E-6)       # priors for intercept
a[2] ~ dnorm (0.0, 1E-6)       # priors for intercept
b[1] ~ dnorm (0.0, 1E-6)       # prior for slope
b[2] ~ dnorm (0.0, 1E-6)       # prior for slope
tau_L   ~ dgamma (0.01, 0.01)    # prior for location-level random effect
tau_eps ~ dgamma (0.01, 0.01)  # prior for observation-level random effect
sd_L   <- pow(tau_L, -1/2)
sd_eps <- pow(tau_eps, -1/2)
b.diff <- b[1] - b[2]
}
jags.data <- list(y     = moth$removed,
n     = moth$placed,
dist  = moth$distance,
loc   = as.numeric(moth$location),
morph = as.numeric(moth$morph),
J     = nrow(moth))
jags.params <- c("a[1]", "a[2]", "b[1]", "b[2]", "b.diff", "sd_L", "sd_eps")
jags.inits <- function(){
list("tau_L" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = moth.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
print(jagsfit)
with(mcmc.output, HPDinterval(b.diff))
inv.logit <- function(x) exp(x) / (1 + exp(x))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
points(x = light$distance, y = light$prop.removed, pch = 16)
#--------- dark morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
points(x = dark$distance, y = dark$prop.removed, pch = 16)
with(mcmc.output, HPDinterval(b.diff))
?bayesplot::mcmc_areas
bayesplot::mcmc_areas(mcmc.output,
pars = c("b.diff"),
prob = 0.95)
table(mcmc.output$b.diff > 0)
post.mean   <- apply(mcmc.output, 2, mean)
post.mean
inv.logit <- function(x) exp(x) / (1 + exp(x))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
post.mean   <- apply(mcmc.output, 2, mean)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
with(post.mean, fitted.mean.curve <- function(x) inv.logit(a.2 + b.2 * x))
post.mean$a.2
post.mean['a.2']
inv.logit <- function(x) exp(x) / (1 + exp(x))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
post.mean   <- apply(mcmc.output, 2, mean)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.2'] + post.mean['b.2'] * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = light$distance, y = light$prop.removed, pch = 16)
#--------- dark morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
points(x = dark$distance, y = dark$prop.removed, pch = 16)
inv.logit <- function(x) exp(x) / (1 + exp(x))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
post.mean   <- apply(mcmc.output, 2, mean)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.2'] + post.mean['b.2'] * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = light$distance, y = light$prop.removed, pch = 16)
#--------- dark morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.1'] + post.mean['b.1'] * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = dark$distance, y = dark$prop.removed, pch = 16)
inv.logit <- function(x) exp(x) / (1 + exp(x))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
post.mean   <- apply(mcmc.output, 2, mean)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.2'] + post.mean['b.2'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = light$distance, y = light$prop.removed, pch = 16)
#--------- dark morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.1'] + post.mean['b.1'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = dark$distance, y = dark$prop.removed, pch = 16)
0.0335 / 4
# probit link
fm1a <- glm(tb ~ length, family = binomial(link = "probit"), data = boar)
# complementary log-log link
fm1b <- glm(tb ~ length, family = binomial(link = "cloglog"), data = boar)
AIC(fm1, fm1a, fm1b)
# make a plot to compare the fits with the different links
predict.fm1a <- predict(fm1a, newdata = new.data, type = "response", se.fit = TRUE)
predict.fm1b <- predict(fm1b, newdata = new.data, type = "response", se.fit = TRUE)
with(boar, plot(tb ~ length))
lines(x = new.data$length, y = predict.fm1$fit, col = "red", lwd = 2)
lines(x = new.data$length, y = predict.fm1a$fit, col = "blue", lwd = 2)
lines(x = new.data$length, y = predict.fm1b$fit, col = "forestgreen", lwd = 2)
legend("left",
leg = c("logit", "probit", "cloglog"),
col = c("red", "blue", "forestgreen"),
pch = 16)
moth.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j]   ~ dbin(p[j], n[j])      # data distribution
p[j]   <- ilogit(eta[j])      # inverse link
eta[j] <- a[morph[j]] + b[morph[j]] * dist[j] + L[loc[j]]  # linear predictor,
}
for (j in 1:7){  # random effects for location
L[j] ~ dnorm(0, tau_L)
}
a[1] ~ dnorm (0.0, 1E-6)       # priors for intercept
a[2] ~ dnorm (0.0, 1E-6)       # priors for intercept
b[1] ~ dnorm (0.0, 1E-6)       # prior for slope
b[2] ~ dnorm (0.0, 1E-6)       # prior for slope
tau_L   ~ dgamma (0.01, 0.01)    # prior for location-level random effect
tau_eps ~ dgamma (0.01, 0.01)  # prior for observation-level random effect
sd_L   <- pow(tau_L, -1/2)
sd_eps <- pow(tau_eps, -1/2)
b.diff <- b[1] - b[2]
}
jags.data <- list(y     = moth$removed,
n     = moth$placed,
dist  = moth$distance,
loc   = as.numeric(moth$location),
morph = as.numeric(moth$morph),
J     = nrow(moth))
jags.params <- c("a[1]", "a[2]", "b[1]", "b[2]", "b.diff", "sd_L", "sd_eps")
jags.inits <- function(){
list("tau_L" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = moth.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
moth.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j]   ~ dbin(p[j], n[j])      # data distribution
p[j]   <- ilogit(eta[j])      # inverse link
eta[j] <- a[morph[j]] + b[morph[j]] * dist[j] + L[loc[j]]  # linear predictor,
}
for (j in 1:7){  # random effects for location
L[j] ~ dnorm(0, tau_L)
}
a[1] ~ dnorm (0.0, 1E-6)       # priors for intercept
a[2] ~ dnorm (0.0, 1E-6)       # priors for intercept
b[1] ~ dnorm (0.0, 1E-6)       # prior for slope
b[2] ~ dnorm (0.0, 1E-6)       # prior for slope
tau_L   ~ dgamma (0.01, 0.01)    # prior for location-level random effect
sd_L   <- pow(tau_L, -1/2)
b.diff <- b[1] - b[2]
}
jags.data <- list(y     = moth$removed,
n     = moth$placed,
dist  = moth$distance,
loc   = as.numeric(moth$location),
morph = as.numeric(moth$morph),
J     = nrow(moth))
jags.params <- c("a[1]", "a[2]", "b[1]", "b[2]", "b.diff", "sd_L")
jags.inits <- function(){
list("tau_L" = runif(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = moth.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
print(jagsfit)
inv.logit <- function(x) exp(x) / (1 + exp(x))
mcmc.output <- as.data.frame(jagsfit$BUGSoutput$sims.list)
post.mean   <- apply(mcmc.output, 2, mean)
subset.samples <- sample(nrow(mcmc.output), size = 100)
moth$prop.removed <- with(moth, removed / placed)
light <- subset(moth, morph == "light")
dark  <- subset(moth, morph == "dark")
par(mfrow = c(1, 2))
#------ light morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Light morph",
ylab = "proprotion removed")
points(x = light$distance, y = light$prop.removed, pch = 16)
for(i in subset.samples) {
a <- mcmc.output$a.2[i]
b <- mcmc.output$b.2[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.2'] + post.mean['b.2'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = light$distance, y = light$prop.removed, pch = 16)
#--------- dark morph
plot(prop.removed ~ distance,
data = moth,
type = "n",
main = "Dark morph",
ylab = "proprotion removed")
for(i in subset.samples) {
a <- mcmc.output$a.1[i]
b <- mcmc.output$b.1[i]
fitted.curve <- function(x) inv.logit(a + b * x)
curve(fitted.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "deepskyblue")
}
fitted.mean.curve <- function(x) inv.logit(post.mean['a.1'] + post.mean['b.1'] * x)
curve(fitted.mean.curve,
from = min(moth$distance),
to   = max(moth$distance),
add  = TRUE,
col  = "darkblue",
lwd  = 2)
points(x = dark$distance, y = dark$prop.removed, pch = 16)
bayesplot::mcmc_areas(mcmc.output,
pars = c("b.diff"),
prob = 0.95)
table(mcmc.output$b.diff > 0)
DIC(jagsfit2)
summary(jagsfit2)
print(jagsfit2)
names(print(jagsfit2))
names(print(jagsfit2))$DIC
print(jagsfit2)$DIC
elephant <- read.table("data/elephant.txt", head = T)
head(elephant)
with(elephant, plot(matings ~ age))
fm1 <- glm(matings ~ age,
family = poisson(link = "log"),
data   = elephant)  # log link is the default
summary(fm1)
require(R2jags)
elephant.model <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dpois(mu[j])      # data model:  the likelihood
mu[j] <- exp(eta[j])      # inverse link
eta[j] <- a + b * x[j]  # linear predictor
}
a ~ dnorm (0.0, 1E-6)       # prior for intercept
b ~ dnorm (0.0, 1E-6)       # prior for slope
}
jags.data <- list(y = elephant$matings,
x = elephant$age,
J = nrow(elephant))
jags.params <- c("a", "b")
jags.inits <- function(){
list("a" = rnorm(1), "b" = rnorm(1))
}
set.seed(1)
jagsfit <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = elephant.model,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
elephant.model.2 <- function() {
for (j in 1:J) {             # J = number of data points
y[j] ~ dpois(mu[j])      # data model:  the likelihood
mu[j] <- exp(eta[j])      # inverse link
eta[j] ~ dnorm(a + b * x[j], tau_eps)  # linear predictor, includes observation-level random effect
}
a ~ dnorm (0.0, 1E-6)       # prior for intercept
b ~ dnorm (0.0, 1E-6)       # prior for slope
tau_eps ~ dgamma (0.01, 0.01)
sd_eps <- pow(tau_eps, -1/2)
}
jags.data <- list(y = elephant$matings,
x = elephant$age,
J = nrow(elephant))
jags.params <- c("a", "b", "sd_eps")
jags.inits <- function(){
list("a" = rnorm(1), "b" = rnorm(1), "tau_eps" = runif(1))
}
set.seed(1)
jagsfit2 <- jags(data               = jags.data,
inits              = jags.inits,
parameters.to.save = jags.params,
model.file         = elephant.model.2,
n.chains           = 3,
n.iter             = 5E4,
n.thin             = 5)
print(jagsfit)
print(jagsfit2)
getwd()
bookdown::render_book("01-LikelihoodIntro.Rmd", "bookdown::gitbook")
